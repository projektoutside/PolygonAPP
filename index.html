<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Geometry Polygon Playground</title>
    <style>
        /* CSS Custom Properties for Responsive Design System */
        :root {
            /* Base font size - scales with viewport */
            --base-font-size: clamp(12px, 1.5vw, 16px);
            --font-scale: 1;

            /* Spacing system - relative units */
            --spacing-xs: clamp(4px, 0.5vw, 6px);
            --spacing-sm: clamp(6px, 0.75vw, 8px);
            --spacing-md: clamp(8px, 1vw, 12px);
            --spacing-lg: clamp(12px, 1.5vw, 16px);
            --spacing-xl: clamp(16px, 2vw, 24px);
            --spacing-2xl: clamp(20px, 2.5vw, 32px);

            /* Touch target sizes - minimum 44px for accessibility */
            --touch-target-min: 44px;
            --touch-target-sm: clamp(36px, 4.5vw, 44px);
            --touch-target-md: clamp(44px, 5.5vw, 56px);
            --touch-target-lg: clamp(48px, 6vw, 64px);

            /* Sidebar widths - responsive */
            --sidebar-width-mobile: 0;
            --sidebar-width-tablet: clamp(200px, 25vw, 280px);
            --sidebar-width-desktop: clamp(240px, 20vw, 320px);

            /* Border radius - scales with size */
            --radius-sm: clamp(4px, 0.5vw, 6px);
            --radius-md: clamp(6px, 0.75vw, 8px);
            --radius-lg: clamp(8px, 1vw, 12px);
            --radius-xl: clamp(12px, 1.5vw, 16px);

            /* Colors */
            --color-primary: #667eea;
            --color-primary-dark: #764ba2;
            --color-bg: rgba(255, 255, 255, 0.95);
            --color-border: #e0e0e0;

            /* Z-index layers */
            --z-toolbar: 1000;
            --z-menu: 1100;
            --z-overlay: 2000;

            /* Device type flags (set by JS) */
            --is-mobile: 0;
            --is-tablet: 0;
            --is-desktop: 1;
            --is-touch: 0;
            --is-portrait: 0;
            --is-landscape: 1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: var(--base-font-size);
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            /* Dynamic viewport height for mobile */
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: var(--base-font-size);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            /* Prevent double-tap zoom on buttons */
        }

        /* Learn Geometry Full Page */
        #learnPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #f8fafc;
            z-index: 3000;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }

        #learnPage.active {
            display: flex;
        }

        .learn-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: clamp(16px, 2vw, 20px) clamp(24px, 4vw, 40px);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .learn-header h1 {
            font-size: clamp(20px, 2.5vw, 24px);
            font-weight: 600;
            margin: 0;
        }

        .close-learn-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .close-learn-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .learn-content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
            padding: clamp(20px, 4vw, 40px);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .learn-card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .learn-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #667eea, #764ba2);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .learn-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
            border-color: transparent;
        }

        .learn-card:hover::before {
            opacity: 1;
        }

        .learn-card-title {
            color: #2d3748;
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .learn-card-icon {
            font-size: 24px;
            background: #f0f4ff;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #667eea;
        }

        .learn-card-desc {
            color: #718096;
            line-height: 1.6;
            font-size: 15px;
        }

        /* Main Layout - Fully Responsive */
        .app-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            max-width: 100%;
            max-height: none;
            background: var(--color-bg);
            border-radius: 0;
            margin: 0;
            overflow: hidden;
            box-shadow: none;
            flex-direction: row;
            position: relative;
        }

        /* Mobile: Stack vertically */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Landscape mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .app-container {
                height: 100vh;
                height: 100dvh;
                margin: 0;
            }
        }

        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            .app-container {
                margin: 0;
            }
        }

        /* Panel Resizing - Responsive */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            flex-shrink: 0;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Divider - Touch-friendly on mobile */
        .panel-divider {
            height: clamp(8px, 1vw, 12px);
            min-height: var(--touch-target-sm);
            background: var(--color-border);
            cursor: row-resize;
            position: relative;
            transition: background 0.2s;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            flex-shrink: 0;
        }

        /* Mobile: Larger touch target for divider */
        @media (max-width: 768px) {
            .panel-divider {
                min-height: var(--touch-target-min);
            }
        }

        .panel-divider:hover {
            background: #94a3b8;
        }

        .panel-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 2px;
            background: #94a3b8;
            border-radius: 1px;
        }

        /* Panel Header with Drag Handle - Responsive */
        .panel-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            font-weight: 600;
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: var(--touch-target-min);
            flex-shrink: 0;
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel-header.dragging .drag-handle {
            color: white;
        }

        /* Toolbar - Compact Top Bar for All Devices */
        .toolbar {
            position: fixed;
            top: clamp(36px, 4.5vw, 44px);
            /* Pushed down by top tools bar */
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-bottom: 1px solid var(--color-border);
            padding: clamp(4px, 0.5vw, 6px) clamp(4px, 0.5vw, 8px);
            display: flex;
            gap: clamp(2px, 0.25vw, 3px);
            z-index: var(--z-toolbar);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
            min-height: clamp(36px, 4.5vw, 44px);
            max-height: clamp(36px, 4.5vw, 44px);
            box-sizing: border-box;
        }

        /* Ensure toolbar buttons fit on small screens */
        @media (max-width: 320px) {
            .toolbar {
                padding: clamp(3px, 0.4vw, 5px) clamp(2px, 0.25vw, 4px);
                gap: clamp(1px, 0.125vw, 2px);
            }

            .tool-btn {
                width: clamp(28px, 3.5vw, 36px);
                min-width: clamp(28px, 3.5vw, 36px);
                height: clamp(26px, 3.25vw, 34px);
                min-height: clamp(26px, 3.25vw, 34px);
                font-size: clamp(12px, 1.5vw, 16px);
            }
        }

        .toolbar::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .toolbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .toolbar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }


        .tool-btn {
            width: clamp(32px, 4vw, 40px);
            min-width: clamp(32px, 4vw, 40px);
            height: clamp(28px, 3.5vw, 36px);
            min-height: clamp(28px, 3.5vw, 36px);
            border: none;
            background: #f0f0f0;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 1.75vw, 18px);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            flex-shrink: 0;
            touch-action: manipulation;
            padding: 0;
            margin: 0;
        }

        .tool-btn:hover {
            background: #e0e0e0;
            transform: scale(1.05);
        }

        .tool-btn:active {
            transform: scale(0.95);
        }

        .tool-btn.active {
            background: var(--color-primary);
            color: white;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .tool-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: clamp(10px, 1.25vw, 12px);
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: calc(var(--z-toolbar) + 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tool-btn:hover::after {
            opacity: 1;
        }

        /* Mobile: Smaller tooltips */
        @media (max-width: 768px) {
            .tool-btn::after {
                display: none;
                /* Hide tooltips on mobile to save space */
            }
        }

        /* Sidebar Panels - Responsive Widths */
        .sidebar {
            width: var(--sidebar-width-desktop);
            min-width: 0;
            max-width: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            flex-shrink: 0;
            transition: transform 0.3s ease, width 0.3s ease;
        }

        .sidebar-right {
            border-right: none;
            border-left: 1px solid var(--color-border);
        }

        /* Mobile: Sidebars become overlays */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: min(85vw, 320px);
                height: 100vh;
                height: 100dvh;
                z-index: var(--z-menu);
                transform: translateX(-100%);
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
            }

            .sidebar.sidebar-right {
                left: auto;
                right: 0;
                transform: translateX(100%);
                border-left: none;
                border-right: 1px solid var(--color-border);
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .sidebar-right.mobile-open {
                transform: translateX(0);
            }
        }

        /* Tablet: Medium sidebar width */
        @media (min-width: 769px) and (max-width: 1024px) {
            .sidebar {
                width: var(--sidebar-width-tablet);
            }
        }

        .panel {
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            padding: var(--spacing-md);
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Canvas Area - Fully Responsive */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fafafa;
            min-width: 0;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        /* Mobile: Canvas takes full height minus toolbar */
        @media (max-width: 768px) {
            .canvas-container {
                flex: 1 1 auto;
                min-height: 0;
                order: -1;
                /* Canvas appears first on mobile */
            }
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            touch-action: none;
            /* Prevent default touch behaviors */
        }

        /* Zoom Controls - Responsive Positioning */
        .zoom-controls {
            position: absolute;
            bottom: clamp(12px, 2vw, 20px);
            right: clamp(12px, 2vw, 20px);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: calc(var(--z-toolbar) - 1);
        }

        /* Mobile: Adjust position to avoid toolbar */
        @media (max-width: 768px) {
            .zoom-controls {
                bottom: clamp(80px, 12vw, 100px);
                right: var(--spacing-md);
            }
        }

        .zoom-btn {
            width: var(--touch-target-md);
            min-width: var(--touch-target-min);
            height: var(--touch-target-md);
            min-height: var(--touch-target-min);
            border: none;
            background: white;
            border-radius: var(--radius-md);
            cursor: pointer;
            box-shadow: 0 clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 8px) rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 2vw, 20px);
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .zoom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Properties Display - Responsive */
        .property-row {
            display: flex;
            justify-content: space-between;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: clamp(13px, 1.75vw, 16px);
            gap: var(--spacing-md);
            min-height: var(--touch-target-sm);
            align-items: center;
        }

        .property-label {
            color: #666;
            flex-shrink: 0;
        }

        .property-value {
            font-weight: 600;
            color: #333;
            text-align: right;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Layer Item - Responsive */
        .layer-item {
            padding: var(--spacing-md);
            background: #f8f8f8;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
        }

        .layer-item:hover {
            background: #f0f0f0;
        }

        .layer-item.selected {
            background: #e8e0ff;
            border: 1px solid #667eea;
        }

        .layer-color {
            width: clamp(28px, 3.5vw, 32px);
            min-width: clamp(28px, 3.5vw, 32px);
            height: clamp(28px, 3.5vw, 32px);
            min-height: clamp(28px, 3.5vw, 32px);
            border-radius: var(--radius-sm);
            border: clamp(2px, 0.25vw, 3px) solid white;
            box-shadow: 0 clamp(1px, 0.125vw, 2px) clamp(2px, 0.375vw, 3px) rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .layer-name {
            flex: 1;
            font-size: clamp(13px, 1.75vw, 16px);
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-actions {
            display: flex;
            gap: 4px;
        }

        .layer-action-btn {
            width: var(--touch-target-sm);
            min-width: var(--touch-target-min);
            height: var(--touch-target-sm);
            min-height: var(--touch-target-min);
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 1.875vw, 18px);
            transition: background 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .layer-action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Learn Panel - Responsive */
        .learn-item {
            padding: var(--spacing-md);
            background: #f0f9ff;
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-sm);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            min-height: var(--touch-target-min);
            touch-action: manipulation;
            display: flex;
            align-items: center;
        }

        .learn-item:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
        }

        .learn-item.active {
            background: #eef2ff;
            border-color: #818cf8;
        }

        .visualizer-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            margin-right: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .learn-item:hover .visualizer-checkbox {
            border-color: #0ea5e9;
        }

        .learn-item.active .visualizer-checkbox {
            background: #4f46e5;
            border-color: #4f46e5;
        }

        .learn-item.active .visualizer-checkbox::after {
            content: '‚úì';
            color: white;
            font-size: 14px;
            font-weight: 800;
        }

        .learn-item-title {
            font-weight: 600;
            color: #0369a1;
            margin-bottom: var(--spacing-xs);
            font-size: clamp(13px, 1.75vw, 16px);
        }

        .learn-item-desc {
            font-size: clamp(12px, 1.625vw, 15px);
            color: #64748b;
            line-height: 1.4;
        }

        /* Triangle Classifier - Responsive */
        .triangle-classifier {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            margin: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .classifier-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: clamp(11px, 1.5vw, 14px);
            margin: clamp(2px, 0.25vw, 4px);
        }

        /* Coordinate Display - Responsive */
        .coord-display {
            position: absolute;
            bottom: clamp(12px, 2vw, 20px);
            left: clamp(12px, 2vw, 20px);
            background: white;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: clamp(11px, 1.5vw, 14px);
            font-family: monospace;
            box-shadow: 0 clamp(2px, 0.5vw, 4px) clamp(6px, 1vw, 8px) rgba(0, 0, 0, 0.1);
            z-index: calc(var(--z-toolbar) - 1);
            max-width: calc(100% - var(--spacing-2xl));
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .coord-display {
                bottom: clamp(80px, 12vw, 100px);
                left: var(--spacing-md);
                max-width: calc(100% - clamp(120px, 20vw, 160px));
            }
        }

        /* Color Picker - Responsive */
        .color-picker {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
            margin-top: var(--spacing-md);
            padding: 0 var(--spacing-md);
        }

        .color-option {
            width: clamp(32px, 4vw, 40px);
            min-width: clamp(32px, 4vw, 40px);
            height: clamp(32px, 4vw, 40px);
            min-height: clamp(32px, 4vw, 40px);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: clamp(2px, 0.25vw, 3px) solid transparent;
            transition: all 0.2s;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: #333;
        }

        .color-option.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* Create New Polygon Button & Menu - Responsive */
        .create-polygon-container {
            position: relative;
            margin-bottom: var(--spacing-lg);
            padding: 0 var(--spacing-md);
        }

        .create-polygon-btn {
            width: 100%;
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
        }

        .create-polygon-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #7c8ff0 0%, #8659af 100%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .create-polygon-btn:hover::before {
            opacity: 1;
        }

        .create-polygon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .create-polygon-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .create-polygon-btn:focus-visible {
            outline: 3px solid #667eea;
            outline-offset: 2px;
        }

        .create-polygon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .create-polygon-btn .btn-icon,
        .create-polygon-btn .btn-chevron {
            position: relative;
            z-index: 1;
        }

        .create-polygon-btn .btn-icon {
            flex-shrink: 0;
        }

        .create-polygon-btn span {
            position: relative;
            z-index: 1;
            flex: 1;
            text-align: left;
        }

        /* Shape Selection Grid - Modal */
        .shape-option-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .shape-option-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .shape-option-card:active {
            transform: translateY(0);
        }

        .shape-option-card .shape-icon {
            width: 48px;
            height: 48px;
            font-size: 24px;
            margin-bottom: 12px;
            background: #eef2ff;
            color: #4f46e5;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-md);
        }

        .shape-option-card .shape-name {
            font-size: 15px;
            margin-bottom: 4px;
            color: #2d3748;
            font-weight: 600;
        }

        .shape-option-card .shape-hint {
            font-size: 12px;
            color: #718096;
        }

        .shape-shortcut {
            padding: 4px 8px;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            font-family: monospace;
        }

        /* Announcement for screen readers */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Flash animation for feedback */
        @keyframes flash {

            0%,
            100% {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }

            50% {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            }
        }



        /* Tutorial Overlay - Responsive */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: var(--z-overlay);
            padding: var(--spacing-lg);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tutorial-modal {
            background: white;
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            max-width: min(90vw, 500px);
            width: 100%;
            max-height: min(90vh, 600px);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
            margin: auto;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tutorial-title {
            font-size: clamp(20px, 3vw, 28px);
            font-weight: 700;
            margin-bottom: var(--spacing-lg);
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tutorial-content {
            font-size: clamp(13px, 1.75vw, 16px);
            line-height: 1.6;
            color: #444;
        }

        .tutorial-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn {
            padding: var(--spacing-md) var(--spacing-lg);
            min-height: var(--touch-target-min);
            border: none;
            border-radius: var(--radius-md);
            font-size: clamp(13px, 1.75vw, 16px);
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Grid Toggle - Responsive */
        /* Top Tools Bar - Professional Tabs */
        .top-tools-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: clamp(36px, 4.5vw, 44px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-md);
            background: white;
            padding: 0 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            /* z-index must be higher than toolbar */
            z-index: calc(var(--z-toolbar) + 1);
            box-sizing: border-box;
        }

        .top-tool-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            height: 100%;
            cursor: pointer;
        }

        .top-tool-item:hover {
            background: #f7fafc;
        }

        .learn-tab-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .learn-tab-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
            opacity: 0.95;
        }

        .grid-toggle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #4a5568;
            font-size: 14px;
            padding-right: 4px;
            border-left: 1px solid #e2e8f0;
            padding-left: 12px;
        }

        /* Mobile: Adjust position */
        @media (max-width: 768px) {
            .top-tools-bar {
                top: clamp(10px, 2vw, 15px);
            }
        }

        .toggle-switch {
            width: 36px;
            height: 20px;
            background: #ccc;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(16px);
        }

        /* Drag Handle for Panels */
        .drag-handle {
            cursor: move;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            -webkit-user-select: none;
            user-select: none;
            /* For Safari compatibility */
            padding: 0 4px;
        }

        .drag-handle:hover {
            color: white;
        }

        .panel-header.dragging {
            opacity: 0.7;
            background: linear-gradient(135deg, #4a6de5 0%, #5a52a3 100%);
        }

        .panel.drag-over {
            box-shadow: 0 0 0 2px #667eea;
        }

        .panel {
            transition: box-shadow 0.2s ease;
        }

        /* Resizable Panel Styles */
        .resizable-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            /* Important for flex children to shrink */
            overflow: hidden;
            position: relative;
        }

        .resizable-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            position: relative;
            padding: var(--spacing-sm);
        }

        /* Custom scrollbar for panels */
        .resizable-panel-content::-webkit-scrollbar {
            width: clamp(6px, 0.75vw, 8px);
        }

        .resizable-panel-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .resizable-panel-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: var(--radius-sm);
        }

        .resizable-panel-content::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Mobile sidebar backdrop */
        .sidebar-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: calc(var(--z-menu) - 1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            display: none;
        }

        @media (max-width: 768px) {
            .sidebar-backdrop {
                display: block;
            }

            .sidebar-backdrop.active {
                opacity: 1;
                pointer-events: auto;
            }
        }

        /* Ensure text is always readable */
        @media (max-width: 768px) {
            body {
                font-size: clamp(14px, 4vw, 16px);
            }
        }

        /* Prevent text from being too small */
        @media (max-width: 320px) {
            :root {
                --base-font-size: 14px;
            }
        }

        /* Large screen optimizations */
        @media (min-width: 1920px) {
            .app-container {
                max-width: none;
                margin: 0;
            }
        }

        /* High DPI display optimizations */
        @media (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 192dpi) {

            .tool-btn,
            .zoom-btn,
            .layer-action-btn {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }

        /* Landscape mobile optimizations */
        @media (max-width: 768px) and (orientation: landscape) {
            .toolbar {
                min-height: clamp(32px, 4vw, 40px);
                max-height: clamp(32px, 4vw, 40px);
                padding: clamp(3px, 0.4vw, 5px) clamp(6px, 0.75vw, 10px);
            }

            .app-container {
                margin-top: clamp(32px, 4vw, 40px);
            }

            .zoom-controls {
                bottom: clamp(50px, 8vw, 70px);
            }

            .coord-display {
                bottom: clamp(50px, 8vw, 70px);
            }
        }

        /* Portrait mobile optimizations */
        @media (max-width: 768px) and (orientation: portrait) {
            .toolbar {
                gap: clamp(2px, 0.25vw, 3px);
                padding: clamp(4px, 0.5vw, 6px) clamp(6px, 0.75vw, 10px);
            }
        }

        /* Ensure all interactive elements are accessible */
        button,
        a,
        [role="button"],
        [tabindex="0"] {
            min-height: var(--touch-target-min);
            min-width: var(--touch-target-min);
        }

        /* Focus states for accessibility */
        *:focus-visible {
            outline: clamp(2px, 0.25vw, 3px) solid var(--color-primary);
            outline-offset: clamp(2px, 0.25vw, 3px);
        }

        /* Smooth transitions for layout changes */
        .app-container,
        .sidebar,
        .canvas-container {
            transition: width 0.3s ease, height 0.3s ease, transform 0.3s ease;
        }

        /* Bottom Properties Panel */
        .bottom-panel {
            width: 100%;
            background: white;
            border-top: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            transition: height 0.3s ease;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            z-index: 1001;
            height: 180px;
            /* Default expanded height */
        }

        .bottom-panel.collapsed {
            height: 40px;
            /* Header height only */
        }

        .bottom-panel-header {
            height: 40px;
            padding: 0 16px;
            background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--color-border);
            cursor: pointer;
        }

        .bottom-panel-title {
            font-weight: 600;
            color: #4a5568;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bottom-panel-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #718096;
            transition: transform 0.3s;
        }

        .bottom-panel.collapsed .bottom-panel-toggle {
            transform: rotate(180deg);
        }

        .bottom-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            align-content: start;
        }

        /* Ensure app container uses column flow */
        .app-container {
            flex-direction: column !important;
        }

        /* Prevent layout shift during resize */
        .canvas-container {
            contain: layout style paint;
        }

        /* Combine Button - Wider for text */
        .tool-btn.combine-btn {
            width: auto;
            min-width: clamp(60px, 8vw, 80px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Split Button */
        .tool-btn.split-btn {
            width: auto;
            min-width: clamp(50px, 6vw, 60px);
            padding: 0 var(--spacing-sm);
            font-weight: 600;
            font-size: clamp(12px, 1.5vw, 14px);
        }

        /* Combine Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            max-width: min(90vw, 400px);
            width: 100%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: clamp(18px, 2.5vw, 22px);
            font-weight: 700;
            color: var(--color-primary-dark);
            margin-bottom: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
            line-height: 1;
        }

        .modal-close-btn:hover {
            background: #edf2f7;
            color: #2d3748;
        }

        .modal-body {
            font-size: clamp(14px, 1.75vw, 16px);
            color: #444;
            line-height: 1.5;
            margin-bottom: var(--spacing-lg);
        }

        .modal-footer {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }

        .modal-btn {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }
    </style>
</head>

<body>

    <div class="app-container">
        <!-- Main Body Row (Sidebars + Canvas) -->
        <div class="main-body-row" style="display: flex; flex: 1; min-height: 0; width: 100%; position: relative;">

            <!-- Mobile Sidebar Backdrop -->
            <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

            <!-- Left Sidebar -->
            <div class="sidebar">

                <!-- Wrapper for Layers Panel full height -->
                <div class="resizable-panel" id="layersPanel" style="height: 100%; flex: 1;">
                    <!-- Layers Panel -->
                    <div class="panel-header">
                        <span>üìê Layers</span>
                        <span id="layerCount">0</span>
                    </div>
                    <div class="resizable-panel-content">
                        <!-- Create New Polygon Button -->
                        <div class="create-polygon-container">
                            <button id="createPolygonBtn" class="create-polygon-btn"
                                aria-label="Open create new polygon menu">
                                <svg class="btn-icon" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7L2 17L12 22L22 17L22 7L12 2Z" />
                                </svg>
                                <span>Create New Polygon</span>
                            </button>
                        </div>

                        <!-- Layers List -->
                        <div id="layersList"></div>
                    </div>
                </div>
            </div>

            <!-- Canvas Container -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="mainCanvas"></canvas>

                <!-- Toolbar -->
                <div class="toolbar">
                    <button class="tool-btn active" data-tool="select" data-tooltip="Select/Move (S)">‚úã</button>

                    <!-- Color Picker Button -->
                    <div style="position: relative; display: inline-flex;">
                        <button class="tool-btn" id="toolbarColorBtn" data-tooltip="Change Color">üé®</button>
                        <input type="color" id="toolbarColorInput" value="#667eea"
                            style="position: absolute; opacity: 0; width: 0; height: 0; pointer-events: none;">
                    </div>

                    <button class="tool-btn combine-btn" data-tool="combine"
                        data-tooltip="Combine Polygons">Combine</button>
                    <button class="tool-btn combine-btn" id="cancelCombineBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Combine">Cancel</button>
                    <button class="tool-btn split-btn" data-tool="split" data-tooltip="Split Polygon">Split</button>
                    <button class="tool-btn split-btn" id="cancelSplitBtn"
                        style="display: none; background: #e53e3e; color: white;"
                        data-tooltip="Cancel Split">Cancel</button>
                    <button class="tool-btn" data-tool="undo" data-tooltip="Undo (Ctrl+Z)">‚Ü∂</button>
                    <button class="tool-btn" data-tool="redo" data-tooltip="Redo (Ctrl+Y)">‚Ü∑</button>
                    <button class="tool-btn" data-tool="save" data-tooltip="Save">üíæ</button>
                    <button class="tool-btn" data-tool="load" data-tooltip="Load">üìÅ</button>
                    <button class="tool-btn" data-tool="reset" data-tooltip="Reset">üîÑ</button>
                </div>

                <!-- Top Tools Bar (Tabs) -->
                <div class="top-tools-bar">
                    <button class="learn-tab-btn" id="openLearnPageBtn">
                        üéì Learn Polygons
                    </button>
                    <div class="grid-toggle-item">
                        <span>Grid Snap</span>
                        <div class="toggle-switch active" id="gridSnapToggle"></div>
                    </div>
                </div>

                <!-- Zoom Controls -->
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomIn">‚ûï</button>
                    <button class="zoom-btn" id="zoomOut">‚ûñ</button>
                    <button class="zoom-btn" id="zoomReset">üîç</button>
                </div>

                <!-- Coordinate Display -->
                <div class="coord-display" id="coordDisplay">X: 0, Y: 0</div>
            </div>

            <!-- Right Sidebar -->
            <div class="sidebar sidebar-right">
                <!-- Visualizers Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <span>üëÅÔ∏è Visualizers</span>
                    </div>
                    <div class="panel-content">
                        <div class="learn-item" data-viz="angles">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Angles</div>
                        </div>
                        <div class="learn-item" data-viz="medians">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Medians & Centroid</div>
                        </div>
                        <div class="learn-item" data-viz="altitudes">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Altitudes & Orthocenter</div>
                        </div>
                        <div class="learn-item" data-viz="bisectors">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Perpendicular Bisectors</div>
                        </div>
                        <div class="learn-item" data-viz="diagonals">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Diagonals</div>
                        </div>
                        <div class="learn-item" data-viz="vertices">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Vertices</div>
                        </div>
                        <div class="learn-item" data-viz="perimeters">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Perimeters</div>
                        </div>
                        <div class="learn-item" data-viz="baseHeight">
                            <div class="visualizer-checkbox"></div>
                            <div class="learn-item-title">Show Base & Height</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Properties Panel -->
        <div id="bottomPropertiesPanel" class="bottom-panel expanded">
            <div class="bottom-panel-header">
                <div class="bottom-panel-title">
                    <span>üìä Properties</span>
                </div>
                <button class="bottom-panel-toggle" id="bottomPanelToggle">
                    <span class="toggle-icon">‚ñº</span>
                </button>
            </div>
            <div class="bottom-panel-content" id="propertiesPanelContent">
                <div class="property-row">
                    <span class="property-label">Select a polygon</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Learn Geometry Full Page -->
    <div id="learnPage">
        <div class="learn-header">
            <h1>üéì Learn Geometry</h1>
            <button class="close-learn-btn" id="closeLearnPageBtn">
                <span>Back to App</span>
                ‚úï
            </button>
        </div>
        <div class="learn-content-grid" id="learnPageContent">
            <!-- Content populated by JS -->
        </div>
    </div>

    <!-- Combine Tool Modal -->
    <!-- Combine Tool Modal -->
    <div class="modal-overlay" id="combineModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Combine Polygons</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('combineModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Please select two or more polygons to combine them into a single morphed polygon.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="combineDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="combineContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Split Tool Modal -->
    <div class="modal-overlay" id="splitModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Split Polygon</span>
                <button class="modal-close-btn"
                    onclick="document.getElementById('splitModal').style.display = 'none'">&times;</button>
            </div>
            <div class="modal-body">
                Use the Line vector to split your polygon into two pieces.
            </div>
            <div class="modal-footer">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="splitDontShowAgain">
                    Don't show this again
                </label>
                <button class="modal-btn" id="splitContinueBtn">Continue</button>
            </div>
        </div>
    </div>

    <!-- Combine Selection Error Modal -->
    <div class="modal-overlay" id="combineSelectionModal" style="z-index: 3100;">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">
                <span class="modal-title">Select Polygons</span>
            </div>
            <div class="modal-body">
                Please select at least two polygons to combine.
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="modal-btn"
                    onclick="document.getElementById('combineSelectionModal').style.display = 'none'">OK</button>
            </div>
        </div>
    </div>

    <!-- Split Selection Confirmation Modal -->
    <div class="modal-overlay" id="splitConfirmSelectionModal">
        <div class="modal-content" style="max-width: 300px; text-align: center;">
            <div class="modal-header" style="justify-content: center;">Confirm Selection</div>
            <div class="modal-body">
                Do you want to split this polygon?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: center;">
                <button class="modal-btn" style="background: #e1e4e8; color: #1a202c;"
                    id="splitCancelSelectionBtn">Cancel</button>
                <button class="modal-btn" style="background: #667eea; color: white;"
                    id="splitConfirmSelectionBtnModal">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div class="modal-overlay" id="resetModal">
        <div class="modal-content">
            <div class="modal-header" style="color: #e53e3e;">‚ö†Ô∏è Reset Everything?</div>
            <div class="modal-body">
                This will clear the entire canvas and cannot be undone. Are you sure you want to proceed?
            </div>
            <div class="modal-footer" style="flex-direction: row; justify-content: flex-end;">
                <button class="modal-btn" id="cancelResetBtn"
                    style="background: #edf2f7; color: #4a5568;">Cancel</button>
                <button class="modal-btn" id="confirmResetBtn" style="background: #e53e3e; color: white;">Yes,
                    Reset</button>
            </div>
        </div>
    </div>

    <!-- Create Shape Modal -->
    <div class="modal-overlay" id="createShapeModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <span>Create New Polygon</span>
                <button id="closeCreateShapeModal" class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 20px; color: #4a5568; font-size: 15px;">Which shape polygon would you like to
                    create?</p>
                <div class="shape-grid"
                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;">
                    <div class="shape-option-card" data-shape="triangle" data-sides="3">
                        <div class="shape-icon">‚ñ≤</div>
                        <div class="shape-name">Triangle</div>
                        <div class="shape-hint">3 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="square" data-sides="4">
                        <div class="shape-icon">‚ñ†</div>
                        <div class="shape-name">Square</div>
                        <div class="shape-hint">4 equal sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="rectangle" data-sides="4">
                        <div class="shape-icon">‚ñ¨</div>
                        <div class="shape-name">Rectangle</div>
                        <div class="shape-hint">4 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="pentagon" data-sides="5">
                        <div class="shape-icon">‚¨ü</div>
                        <div class="shape-name">Pentagon</div>
                        <div class="shape-hint">5 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="hexagon" data-sides="6">
                        <div class="shape-icon">‚¨¢</div>
                        <div class="shape-name">Hexagon</div>
                        <div class="shape-hint">6 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="heptagon" data-sides="7">
                        <div class="shape-icon">‚¨†</div>
                        <div class="shape-name">Heptagon</div>
                        <div class="shape-hint">7 sides</div>
                    </div>
                    <div class="shape-option-card" data-shape="octagon" data-sides="8">
                        <div class="shape-icon">‚¨°</div>
                        <div class="shape-name">Octagon</div>
                        <div class="shape-hint">8 sides</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal-overlay" id="tutorialOverlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="justify-content: center;">
                <span class="tutorial-title" style="margin: 0; font-size: 24px;">Welcome to Geometry Playground!
                    üéâ</span>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 12px;"><strong>Get started:</strong></p>
                <ul style="margin: 12px 0; padding-left: 20px;">
                    <li>Click "Create New Polygon" for quick shapes</li>
                    <li>Use ‚úã to select and move shapes</li>
                    <li>Zoom with scroll wheel or buttons</li>
                    <li>Click "Learn" üéì for definitions</li>
                </ul>
                <p style="margin-top: 12px; font-size: 0.9em; color: #666;"><strong>Keyboard shortcuts:</strong> Ctrl+N
                    (New shape), S (Select), Space (Pan), Ctrl+Z (Undo)</p>
            </div>
            <div class="modal-footer">
                <button class="modal-btn" onclick="closeTutorial()">Let's Start!</button>
            </div>
        </div>
    </div>
    <!-- Learn Page Overlay -->
    <div id="learnPage"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; background: #f8fafc; display: none; flex-direction: column;">
        <div class="learn-header"
            style="background: white; padding: 16px 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); display: flex; align-items: center; justify-content: space-between; position: relative; z-index: 10;">
            <div
                style="font-size: 24px; font-weight: 700; color: #2d3748; display: flex; align-items: center; gap: 12px;">
                üéì Learn Polygons
            </div>
            <button id="closeLearnPageBtn"
                style="padding: 8px 16px; background: #edf2f7; color: #4a5568; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                Back to App
            </button>
        </div>
        <div style="flex: 1; overflow-y: auto; padding: 24px;">
            <div id="learnPageContent" class="learn-content-grid">
                <!-- Content populated by JS -->
            </div>
        </div>
    </div>

    <script>
        // Device Detection and Viewport Intelligence System
        class DeviceDetector {
            constructor() {
                this.deviceInfo = {
                    type: 'desktop',
                    isMobile: false,
                    isTablet: false,
                    isDesktop: true,
                    isTouch: false,
                    orientation: 'landscape',
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                    aspectRatio: window.innerWidth / window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                };

                this.updateDeviceInfo();
                this.setupListeners();
                this.applyDeviceClasses();
            }

            updateDeviceInfo() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const aspectRatio = width / height;

                // Detect device type
                this.deviceInfo.screenWidth = width;
                this.deviceInfo.screenHeight = height;
                this.deviceInfo.aspectRatio = aspectRatio;
                this.deviceInfo.orientation = width > height ? 'landscape' : 'portrait';

                // Touch detection
                this.deviceInfo.isTouch = 'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0;

                // Device type detection
                if (width <= 768) {
                    this.deviceInfo.type = 'mobile';
                    this.deviceInfo.isMobile = true;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = false;
                } else if (width <= 1024) {
                    this.deviceInfo.type = 'tablet';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = true;
                    this.deviceInfo.isDesktop = false;
                } else {
                    this.deviceInfo.type = 'desktop';
                    this.deviceInfo.isMobile = false;
                    this.deviceInfo.isTablet = false;
                    this.deviceInfo.isDesktop = true;
                }
            }

            setupListeners() {
                // Resize handler with debouncing
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onResize();
                    }, 100);
                });

                // Orientation change handler
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.updateDeviceInfo();
                        this.applyDeviceClasses();
                        this.onOrientationChange();
                    }, 100);
                });

                // Touch detection
                document.addEventListener('touchstart', () => {
                    if (!this.deviceInfo.isTouch) {
                        this.deviceInfo.isTouch = true;
                        this.applyDeviceClasses();
                    }
                }, { once: true });
            }

            applyDeviceClasses() {
                const root = document.documentElement;
                const body = document.body;

                // Remove existing classes
                body.classList.remove('device-mobile', 'device-tablet', 'device-desktop',
                    'is-touch', 'is-mouse', 'orientation-portrait', 'orientation-landscape');

                // Add device type classes
                body.classList.add(`device-${this.deviceInfo.type}`);

                // Add touch/mouse classes
                if (this.deviceInfo.isTouch) {
                    body.classList.add('is-touch');
                } else {
                    body.classList.add('is-mouse');
                }

                // Add orientation classes
                body.classList.add(`orientation-${this.deviceInfo.orientation}`);

                // Set CSS custom properties
                root.style.setProperty('--is-mobile', this.deviceInfo.isMobile ? '1' : '0');
                root.style.setProperty('--is-tablet', this.deviceInfo.isTablet ? '1' : '0');
                root.style.setProperty('--is-desktop', this.deviceInfo.isDesktop ? '1' : '0');
                root.style.setProperty('--is-touch', this.deviceInfo.isTouch ? '1' : '0');
                root.style.setProperty('--is-portrait', this.deviceInfo.orientation === 'portrait' ? '1' : '0');
                root.style.setProperty('--is-landscape', this.deviceInfo.orientation === 'landscape' ? '1' : '0');
            }

            onResize() {
                // Trigger custom event for other components
                window.dispatchEvent(new CustomEvent('deviceResize', {
                    detail: this.deviceInfo
                }));
            }

            onOrientationChange() {
                // Trigger custom event for orientation changes
                window.dispatchEvent(new CustomEvent('deviceOrientationChange', {
                    detail: this.deviceInfo
                }));
            }

            getInfo() {
                return { ...this.deviceInfo };
            }
        }

        // Global device detector instance
        let deviceDetector;

        // Geometry Polygon Playground - Main Application
        class PolygonPlayground {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvasContainer');

                // Initialize device detector
                if (!deviceDetector) {
                    deviceDetector = new DeviceDetector();
                }
                this.deviceInfo = deviceDetector.getInfo();

                // State
                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.currentTool = 'select';
                this.gridSize = 20;
                this.gridSnap = true;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null; // Track initial click position for pan detection
                this.panThreshold = 5; // Minimum pixels to move before starting pan
                this.history = [];
                this.historyIndex = -1;
                this.visualizers = new Set();
                this.colors = [
                    '#667eea', '#f56565', '#48bb78', '#ed8936', '#9f7aea',
                    '#38b2ac', '#f687b3', '#4299e1', '#ecc94b', '#a0aec0'
                ];
                this.currentColor = '#667eea';

                // Combine Tool State
                this.combineMode = false;
                this.combineSelection = new Set();

                // Split Tool State
                this.splitMode = false;
                this.splitStep = 0; // 0: Select Polygon, 1: Draw Line
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free'; // 'free', 'horizontal', 'vertical'

                // Mouse tracking
                this.mousePos = { x: 0, y: 0 };
                this.mouseWorldPos = { x: 0, y: 0 };

                // Shape menu state
                this.shapeMenuOpen = false;
                this.currentMenuIndex = -1;
                this.lastUsedShape = localStorage.getItem('lastUsedShape') || 'triangle';
                this.lastShapeCreationTime = 0; // Debounce for shape creation

                // Telemetry callbacks
                this.telemetry = {
                    onShapeMenuOpen: null,
                    onShapeMenuClose: null,
                    onShapeSelect: null
                };

                // Panel resizing state
                this.isResizing = false;
                this.activeDivider = null;
                this.startY = 0;
                this.startHeight = 0;
                this.originalHeights = [];

                // Touch/pinch state
                this.isPinching = false;
                this.pinchDistance = 0;
                this.pinchZoom = 1;

                this.init();
            }

            setTelemetryCallbacks(callbacks) {
                this.telemetry = { ...this.telemetry, ...callbacks };
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.setupColorPicker();
                this.setupLearnPanel();
                this.setupResizablePanels();
                this.setupShapeMenu();
                this.setupResponsiveHandlers();

                // Ensure layout is settled before creating polygon so it is perfectly centered
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        this.resizeCanvas();
                        this.createSamplePolygon();
                        this.render();
                    });
                });

                // Show tutorial on first load
                if (!localStorage.getItem('tutorialShown')) {
                    document.getElementById('tutorialOverlay').style.display = 'flex';
                    localStorage.setItem('tutorialShown', 'true');
                }
            }

            setupResponsiveHandlers() {
                // Handle device resize
                window.addEventListener('deviceResize', (e) => {
                    this.deviceInfo = e.detail;
                    this.handleViewportChange();
                });

                // Handle orientation change
                window.addEventListener('deviceOrientationChange', (e) => {
                    this.deviceInfo = e.detail;
                    this.handleViewportChange();
                    this.resizeCanvas();
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.handleViewportChange();
                });

                // Initial viewport setup
                this.handleViewportChange();
            }

            handleViewportChange() {
                // Update mobile sidebar visibility
                if (this.deviceInfo.isMobile) {
                    // Close sidebars by default on mobile
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.remove('mobile-open');
                    });
                } else {
                    // Show sidebars on desktop/tablet
                    document.querySelectorAll('.sidebar').forEach(sidebar => {
                        sidebar.classList.add('mobile-open');
                    });
                }

                // Adjust toolbar for mobile
                const toolbar = document.querySelector('.toolbar');
                if (toolbar && this.deviceInfo.isMobile) {
                    toolbar.scrollLeft = 0; // Reset scroll on mobile
                }

                // Ensure canvas is properly sized
                this.resizeCanvas();
            }

            setupResizablePanels() {
                const divider1 = document.getElementById('divider1');
                const layersPanel = document.getElementById('layersPanel');
                const colorPanel = document.getElementById('colorPanel');

                // Set initial heights for sidebar panels
                const sidebar = document.querySelector('.sidebar');
                if (!sidebar) return; // Guard clause

                const totalHeight = sidebar.clientHeight;

                // Split 50/50 between Layers and Color since Properties is gone
                const panelHeight = Math.floor(totalHeight * 0.5);

                if (layersPanel) layersPanel.style.height = panelHeight + 'px';
                if (colorPanel) colorPanel.style.height = panelHeight + 'px';

                // Make divider draggable
                if (divider1 && layersPanel && colorPanel) {
                    divider1.addEventListener('mousedown', (e) => {
                        this.isResizing = true;
                        this.activeDivider = divider1;
                        this.startY = e.clientY;
                        this.startHeight = parseInt(window.getComputedStyle(layersPanel).height);

                        document.body.style.cursor = 'row-resize';
                        document.body.style.userSelect = 'none';

                        e.preventDefault();
                    });

                    // Global resize handlers
                    document.addEventListener('mousemove', (e) => {
                        if (!this.isResizing || this.activeDivider !== divider1) return;

                        const deltaY = e.clientY - this.startY;
                        const newHeight1 = Math.max(50, this.startHeight + deltaY);
                        // Adjust second panel to fill remaining space
                        // Note: Flexbox usually handles the fill, but setting specific height might fight it.
                        // Ideally we rely on flex-grow, but since we're using explicit heights:
                        // Let's just update the first panel and let flex take care of the rest or update both.
                        // For simplicity in this existing system, we update both.
                        const sidebarRect = sidebar.getBoundingClientRect();
                        const availableHeight = sidebarRect.height - 12; // divider height
                        const newHeight2 = Math.max(50, availableHeight - newHeight1);

                        layersPanel.style.height = newHeight1 + 'px';
                        colorPanel.style.height = newHeight2 + 'px';

                        this.resizeCanvas();
                    });

                    document.addEventListener('mouseup', () => {
                        if (this.isResizing) {
                            this.isResizing = false;
                            this.activeDivider = null;
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                        }
                    });
                }

                this.setupBottomPanel();
            }

            setupBottomPanel() {
                const toggleBtn = document.getElementById('bottomPanelToggle');
                const panel = document.getElementById('bottomPropertiesPanel');

                if (toggleBtn && panel) {
                    toggleBtn.addEventListener('click', () => {
                        panel.classList.toggle('collapsed');
                        // Trigger resize to adjust canvas
                        setTimeout(() => this.resizeCanvas(), 310);
                    });
                }
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                // Use requestAnimationFrame for smooth resizing
                requestAnimationFrame(() => {
                    const rect = this.container.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;

                    // Set canvas size accounting for device pixel ratio
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;

                    // Scale context to match device pixel ratio
                    this.ctx.scale(dpr, dpr);

                    // Set CSS size to maintain aspect ratio
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';

                    this.render();
                });
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // UI events
                document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
                document.getElementById('zoomReset').addEventListener('click', () => this.zoomReset());
                document.getElementById('gridSnapToggle').addEventListener('click', () => this.toggleGridSnap());

                // Visualizer toggles
                document.querySelectorAll('[data-viz]').forEach(item => {
                    item.addEventListener('click', () => {
                        const viz = item.dataset.viz;
                        if (this.visualizers.has(viz)) {
                            this.visualizers.delete(viz);
                            item.classList.remove('active');
                        } else {
                            this.visualizers.add(viz);
                            item.classList.add('active');
                        }
                        this.render();
                    });
                });
            }

            setupToolbar() {
                const tools = document.querySelectorAll('[data-tool]');
                tools.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tool = btn.dataset.tool;

                        if (tool === 'undo') {
                            this.undo();
                        } else if (tool === 'redo') {
                            this.redo();
                        } else if (tool === 'save') {
                            this.save();
                        } else if (tool === 'load') {
                            this.load();
                        } else if (tool === 'reset') {
                            this.reset();
                        } else if (tool === 'combine') {
                            this.handleCombineToolClick();
                        } else if (tool === 'split') {
                            this.handleSplitToolClick();
                        } else {
                            // Tool selection
                            if (this.combineMode && tool !== 'combine') {
                                this.exitCombineMode();
                            }
                            if (this.splitMode && tool !== 'split') {
                                this.exitSplitMode();
                            }
                            tools.forEach(t => t.classList.remove('active'));
                            btn.classList.add('active');
                            this.currentTool = tool;
                            this.updateCursor();
                        }
                    });
                });

                // Setup Cancel Combine Button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        this.exitCombineMode();
                        this.setTool('select');
                    });
                }

                // Setup Cancel Split Button
                const cancelSplitBtn = document.getElementById('cancelSplitBtn');
                if (cancelSplitBtn) {
                    cancelSplitBtn.addEventListener('click', () => {
                        this.exitSplitMode();
                        this.setTool('select');
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const splitConfirmBtn = document.getElementById('splitConfirmSelectionBtnModal');
                if (splitConfirmBtn) {
                    splitConfirmBtn.addEventListener('click', () => {
                        const confirmModal = document.getElementById('splitConfirmSelectionModal');
                        if (confirmModal) confirmModal.style.display = 'none';

                        // Execute split setup
                        this.splitStep = 1; // Move to line drawing
                        this.updateSplitLineConstraint(this.selectedPolygon.getCenter()); // Init
                        this.render();
                    });
                }

                // Setup Reset Modal Buttons
                const resetModal = document.getElementById('resetModal');
                const confirmResetBtn = document.getElementById('confirmResetBtn');
                const cancelResetBtn = document.getElementById('cancelResetBtn');

                if (confirmResetBtn) {
                    confirmResetBtn.addEventListener('click', () => {
                        this.executeReset();
                        resetModal.style.display = 'none';
                    });
                }

                if (cancelResetBtn) {
                    cancelResetBtn.addEventListener('click', () => {
                        resetModal.style.display = 'none';
                    });
                }

                // Close reset modal on outside click
                if (resetModal) {
                    resetModal.addEventListener('click', (e) => {
                        if (e.target === resetModal) {
                            resetModal.style.display = 'none';
                        }
                    });
                }

                // Setup Split Confirmation Modal Buttons
                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                const cancelSelBtn = document.getElementById('splitCancelSelectionBtn');
                const confirmSelBtn = document.getElementById('splitConfirmSelectionBtnModal');

                if (cancelSelBtn) {
                    cancelSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.selectedPolygon = null;
                        this.render();
                    };
                }

                if (confirmSelBtn) {
                    confirmSelBtn.onclick = () => {
                        confirmModal.style.display = 'none';
                        this.splitStep = 1; // Move to drawing line phase
                        this.updateSplitPrompt("Step 2: Draw a line across the polygon to split it.");
                        this.render();
                    };
                }
            }

            setupColorPicker() {
                const colorBtn = document.getElementById('toolbarColorBtn');
                const colorInput = document.getElementById('toolbarColorInput');

                if (colorBtn && colorInput) {
                    // Sync button color with current selection
                    const updateButtonColor = (color) => {
                        colorBtn.style.color = color;
                        // Optional: Add a small indicator or border
                        colorBtn.style.borderBottom = `3px solid ${color}`;
                    };

                    updateButtonColor(this.currentColor);

                    // When button is clicked, trigger the hidden color input
                    colorBtn.addEventListener('click', () => {
                        colorInput.click();
                    });

                    // Handle color change
                    colorInput.addEventListener('input', (e) => {
                        const color = e.target.value;
                        this.currentColor = color;
                        updateButtonColor(color);

                        if (this.selectedPolygon) {
                            this.selectedPolygon.color = color;
                            this.saveHistory();
                            this.render();
                            this.updateLayers(); // To update the color indicator in layers
                        }
                    });

                    // Also handle direct confirmation (change event)
                    colorInput.addEventListener('change', (e) => {
                        this.saveHistory(); // Ensure history is saved on final selection
                    });
                }
            }

            setupShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                const createPolygonBtn = document.getElementById('createPolygonBtn');
                const closeBtn = document.getElementById('closeCreateShapeModal');

                // Open Modal
                createPolygonBtn.addEventListener('click', (e) => {
                    this.openShapeMenu();
                });

                // Close Modal with X button
                closeBtn.addEventListener('click', () => {
                    this.closeShapeMenu();
                });

                // Close Modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeShapeMenu();
                    }
                });

                // Handle shape selection
                document.querySelectorAll('.shape-option-card').forEach(option => {
                    option.addEventListener('click', (e) => {
                        this.selectShape(e.currentTarget);
                    });
                });
            }

            toggleShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                if (modal.style.display === 'flex') {
                    this.closeShapeMenu();
                } else {
                    this.openShapeMenu();
                }
            }

            openShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'flex';
                this.shapeMenuOpen = true;

                if (this.telemetry.onShapeMenuOpen) {
                    this.telemetry.onShapeMenuOpen();
                }
            }

            closeShapeMenu() {
                const modal = document.getElementById('createShapeModal');
                modal.style.display = 'none';
                this.shapeMenuOpen = false;

                if (this.telemetry.onShapeMenuClose) {
                    this.telemetry.onShapeMenuClose();
                }
            }

            selectShape(option) {
                // simple debounce to prevent double-click creation
                const now = Date.now();
                if (now - this.lastShapeCreationTime < 500) return;
                this.lastShapeCreationTime = now;

                const shapeType = option.dataset.shape;
                const sides = parseInt(option.dataset.sides);

                // Get the center of the current viewport, snapped to grid
                const viewportCenter = this.getViewportCenter();
                const centerX = viewportCenter.x;
                const centerY = viewportCenter.y;

                // Create polygon based on shape type, centered on viewport
                let vertices;
                switch (shapeType) {
                    case 'triangle':
                        // Equilateral triangle, 60 units per side (snapped to grid)
                        const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                            { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                            { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                        ];
                        break;
                    case 'square':
                        // Square, 60 units per side (snapped to grid)
                        const squareSize = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfSize = squareSize / 2;
                        vertices = [
                            { x: centerX - halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY - halfSize },
                            { x: centerX + halfSize, y: centerY + halfSize },
                            { x: centerX - halfSize, y: centerY + halfSize }
                        ];
                        break;
                    case 'rectangle':
                        // Rectangle, 80x60 units (snapped to grid)
                        const rectWidth = Math.round(80 / this.gridSize) * this.gridSize;
                        const rectHeight = Math.round(60 / this.gridSize) * this.gridSize;
                        const halfWidth = rectWidth / 2;
                        const halfHeight = rectHeight / 2;
                        vertices = [
                            { x: centerX - halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY - halfHeight },
                            { x: centerX + halfWidth, y: centerY + halfHeight },
                            { x: centerX - halfWidth, y: centerY + halfHeight }
                        ];
                        break;
                    case 'pentagon':
                        vertices = this.createRegularPolygon(5, 50, centerX, centerY);
                        break;
                    case 'hexagon':
                        vertices = this.createRegularPolygon(6, 40, centerX, centerY);
                        break;
                    case 'heptagon':
                        vertices = this.createRegularPolygon(7, 35, centerX, centerY);
                        break;
                    case 'octagon':
                        vertices = this.createRegularPolygon(8, 30, centerX, centerY);
                        break;
                    default:
                        // Default to triangle
                        const defaultSize = Math.round(60 / this.gridSize) * this.gridSize;
                        vertices = [
                            { x: centerX, y: centerY - defaultSize * 0.577 },
                            { x: centerX - defaultSize * 0.5, y: centerY + defaultSize * 0.289 },
                            { x: centerX + defaultSize * 0.5, y: centerY + defaultSize * 0.289 }
                        ];
                }

                // Snap all vertices to grid to ensure perfect grid alignment
                vertices = vertices.map(v => this.snapToGrid(v));

                const polygon = new Polygon(vertices, this.currentColor);
                polygon.name = `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} ${this.polygons.length + 1}`;
                this.polygons.push(polygon);
                this.selectedPolygon = polygon;
                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
                this.render();

                this.closeShapeMenu();

                if (this.telemetry.onShapeSelect) {
                    this.telemetry.onShapeSelect({
                        type: shapeType,
                        sides: sides,
                        polygon: polygon
                    });
                }

                // Store last used shape
                localStorage.setItem('lastUsedShape', shapeType);
            }

            createRegularPolygon(sides, radius, centerX, centerY) {
                // Snap center to grid
                const snappedCenter = this.snapToGrid({ x: centerX, y: centerY });
                centerX = snappedCenter.x;
                centerY = snappedCenter.y;

                // Snap radius to grid for better alignment
                radius = Math.round(radius / this.gridSize) * this.gridSize;

                const vertices = [];
                const angleStep = (Math.PI * 2) / sides;

                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep - Math.PI / 2; // Start from top
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    // Snap each vertex to grid for perfect alignment
                    vertices.push(this.snapToGrid({ x, y }));
                }

                return vertices;
            }

            setupLearnPanel() {
                const concepts = [
                    // Fundamentals
                    { title: 'Polygon', desc: 'A closed shape with straight sides. From Greek "poly" (many) and "gonia" (angle).', icon: '‚¨°' },
                    { title: 'Vertex', desc: 'A corner point where two sides meet.', icon: '‚Ä¢' },
                    { title: 'Edge', desc: 'A line segment joining two vertices of a polygon.', icon: '‚ï±' },
                    { title: 'Perimeter', desc: 'The total distance around the outside of a shape.', icon: 'üìè' },
                    { title: 'Area', desc: 'The amount of space inside a 2D shape.', icon: '‚¨õ' },
                    { title: 'Regular Polygon', desc: 'A polygon with all sides equal and all angles equal.', icon: 'üõë' },
                    { title: 'Irregular Polygon', desc: 'A polygon where sides and/or angles are not all equal.', icon: 'üó∫Ô∏è' },

                    // Angles & Geometry
                    { title: 'Interior Angle', desc: 'An angle inside the polygon at one of its vertices.', icon: '‚à†' },
                    { title: 'Exterior Angle', desc: 'The angle between a side of a polygon and an adjacent side extended outward.', icon: '‚Ü™Ô∏è' },
                    { title: 'Convex', desc: 'A polygon with no interior angle greater than 180¬∞. All vertices point outwards.', icon: '‚è∫Ô∏è' },
                    { title: 'Concave', desc: 'A polygon with at least one interior angle greater than 180¬∞. Has a "cave" or dent.', icon: 'üåô' },
                    { title: 'Diagonal', desc: 'A line segment connecting two non-adjacent vertices.', icon: '‚ö°' },
                    { title: 'Apothem', desc: 'A line from the center of a regular polygon perpendicular to a side.', icon: '‚ä•' },
                    { title: 'Radius', desc: 'A line from the center of a regular polygon to a vertex.', icon: '‚®Ç' },

                    // Triangles
                    { title: 'Triangle', desc: 'A polygon with 3 sides and 3 angles. Sum of angles is 180¬∞.', icon: '‚ñ≤' },
                    { title: 'Equilateral', desc: 'Triangle with all 3 sides equal and all angles 60¬∞.', icon: '‚ñ≥' },
                    { title: 'Isosceles', desc: 'Triangle with at least 2 sides equal.', icon: 'üìê' },
                    { title: 'Scalene', desc: 'Triangle with no equal sides.', icon: 'üìê' },
                    { title: 'Right Triangle', desc: 'Triangle with one 90¬∞ angle.', icon: '‚àü' },
                    { title: 'Centroid', desc: 'The geometric center of a triangle, where medians meet.', icon: 'üéØ' },
                    { title: 'Altitude', desc: 'Perpendicular line from a vertex to the opposite side (or its extension).', icon: '‚ä•' },
                    { title: 'Median', desc: 'Line from a vertex to the midpoint of the opposite side.', icon: '‚´ñ' },

                    // Quadrilaterals
                    { title: 'Quadrilateral', desc: 'A polygon with 4 sides and 4 angles. Sum of angles is 360¬∞.', icon: '‚¨ú' },
                    { title: 'Square', desc: 'Regular quadrilateral with 4 equal sides and 4 right angles.', icon: '‚ñ†' },
                    { title: 'Rectangle', desc: 'Quadrilateral with 4 right angles. Opposite sides are equal.', icon: '‚ñ¨' },
                    { title: 'Rhombus', desc: 'Quadrilateral with 4 equal sides, but no right angles.', icon: 'üî∂' },
                    { title: 'Parallelogram', desc: 'Quadrilateral with 2 pairs of parallel sides.', icon: '‚ñ±' },
                    { title: 'Trapezoid', desc: 'Quadrilateral with at least 1 pair of parallel sides.', icon: '‚è¢' },
                    { title: 'Kite', desc: 'Quadrilateral with 2 pairs of equal-length adjacent sides.', icon: 'ü™Å' },

                    // Other Polygons
                    { title: 'Pentagon', desc: 'A polygon with 5 sides. Sum of angles is 540¬∞.', icon: '‚¨ü' },
                    { title: 'Hexagon', desc: 'A polygon with 6 sides. Sum of angles is 720¬∞.', icon: '‚¨¢' },
                    { title: 'Heptagon', desc: 'A polygon with 7 sides.', icon: '‚¨†' },
                    { title: 'Octagon', desc: 'A polygon with 8 sides. Stop signs are regular octagons.', icon: 'üõë' },
                    { title: 'Nonagon', desc: 'A polygon with 9 sides.', icon: '‚óã' },
                    { title: 'Decagon', desc: 'A polygon with 10 sides.', icon: 'üîü' },
                    { title: 'Dodecagon', desc: 'A polygon with 12 sides.', icon: 'üïõ' },
                    { title: 'n-gon', desc: 'A polygon with n sides.', icon: '‚ôæÔ∏è' }
                ];

                const panel = document.getElementById('learnPageContent');
                concepts.forEach(concept => {
                    const item = document.createElement('div');
                    item.className = 'learn-card';
                    item.innerHTML = `
                            <div class="learn-card-title">
                                ${concept.title}
                                <div class="learn-card-icon">${concept.icon}</div>
                            </div>
                            <div class="learn-card-desc">${concept.desc}</div>
                        `;
                    // item.addEventListener('click', () => this.highlightConcept(concept.title)); // Optional: close and highlight
                    panel.appendChild(item);
                });

                this.setupLearnPageToggles();
            }

            setupLearnPageToggles() {
                const openBtn = document.getElementById('openLearnPageBtn');
                const closeBtn = document.getElementById('closeLearnPageBtn');
                const learnPage = document.getElementById('learnPage');

                openBtn.addEventListener('click', () => {
                    learnPage.classList.add('active');
                    // Hide scroll on main body to prevent scrolling background
                    document.body.style.overflow = 'hidden';
                });

                const closePage = () => {
                    learnPage.classList.remove('active');
                    document.body.style.overflow = '';
                };

                closeBtn.addEventListener('click', closePage);

                // Optional: Close on Esc
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && learnPage.classList.contains('active')) {
                        closePage();
                    }
                });
            }

            createSamplePolygon() {
                // Create a sample triangle centered on viewport, snapped to grid
                const viewportCenter = this.getViewportCenter();
                const centerX = viewportCenter.x;
                const centerY = viewportCenter.y;

                // Equilateral triangle, 60 units per side (snapped to grid)
                const triSize = Math.round(60 / this.gridSize) * this.gridSize;
                const vertices = [
                    { x: centerX, y: centerY - triSize * 0.577 }, // Top vertex
                    { x: centerX - triSize * 0.5, y: centerY + triSize * 0.289 }, // Bottom left
                    { x: centerX + triSize * 0.5, y: centerY + triSize * 0.289 }  // Bottom right
                ].map(v => this.snapToGrid(v));

                const triangle = new Polygon(vertices, this.currentColor);
                triangle.name = 'Triangle 1';
                this.polygons.push(triangle);

                // Select the default polygon so properties are visible immediately
                this.selectedPolygon = triangle;

                this.saveHistory();
                this.updateProperties();
                this.updateLayers();
                this.render();
            }

            handleCombineToolClick() {
                if (this.combineMode) {
                    // Second click: Execute Combine
                    this.executeCombine();
                } else {
                    // First click: Enter Selection Mode
                    if (localStorage.getItem('hideCombineWarning') === 'true') {
                        this.enterCombineMode();
                    } else {
                        this.showCombineModal();
                    }
                }
            }

            showCombineModal() {
                const modal = document.getElementById('combineModal');
                const continueBtn = document.getElementById('combineContinueBtn');
                const checkbox = document.getElementById('combineDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup (or remove old ones to be safe, but simple is ok here)
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideCombineWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterCombineMode();
                };

                // Close on outside click? Maybe not for this specific modal flow.
            }

            enterCombineMode() {
                this.combineMode = true;
                this.combineSelection.clear();
                this.setTool('combine'); // Visual update for button

                // Update button text or style to indicate "Execute"
                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Execute Combine';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                }

                // Show Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'flex';
                }

                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.render();
            }

            exitCombineMode() {
                this.combineMode = false;
                this.combineSelection.clear();

                const btn = document.querySelector('[data-tool="combine"]');
                if (btn) {
                    btn.textContent = 'Combine';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                }

                // Hide Cancel button
                const cancelBtn = document.getElementById('cancelCombineBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'none';
                }

                this.render();
            }

            executeCombine() {
                if (this.combineSelection.size < 2) {
                    const errorModal = document.getElementById('combineSelectionModal');
                    if (errorModal) {
                        errorModal.style.display = 'flex';
                    }
                    return;
                }

                const polygonsToCombine = Array.from(this.combineSelection);

                try {
                    const unionResultVertices = PolygonBoolean.union(polygonsToCombine);

                    if (unionResultVertices && unionResultVertices.length >= 3) {
                        // Success

                        // Remove old polygons
                        this.polygons = this.polygons.filter(p => !this.combineSelection.has(p));

                        // Add new polygon
                        const newPoly = new Polygon(unionResultVertices, this.currentColor);
                        newPoly.name = 'Combined Polygon ' + (this.polygons.length + 1);
                        this.polygons.push(newPoly);

                        this.selectedPolygon = newPoly;
                        this.saveHistory(); // Save AFTER modification
                        this.updateProperties();
                        this.updateLayers();
                        this.exitCombineMode();
                        this.setTool('select');

                        // Show success feedback?
                    } else {
                        alert('Could not combine polygons. Ensure they overlap and form a valid shape.');
                    }
                } catch (e) {
                    console.error(e);
                    alert('Error combining polygons: ' + e.message);
                }
            }

            handleSplitToolClick() {
                if (this.splitMode) {
                    // Second click: Execute Split
                    this.executeSplit();
                } else {
                    // First click: Enter Split Mode
                    if (localStorage.getItem('hideSplitWarning') === 'true') {
                        this.enterSplitMode();
                    } else {
                        this.showSplitModal();
                    }
                }
            }

            showSplitModal() {
                const modal = document.getElementById('splitModal');
                const continueBtn = document.getElementById('splitContinueBtn');
                const checkbox = document.getElementById('splitDontShowAgain');

                modal.style.display = 'flex';

                // One-time listener setup
                continueBtn.onclick = () => {
                    if (checkbox.checked) {
                        localStorage.setItem('hideSplitWarning', 'true');
                    }
                    modal.style.display = 'none';
                    this.enterSplitMode();
                };
            }

            enterSplitMode() {
                this.splitMode = true;
                this.splitStep = 0; // 0: Select Polygon
                this.splitLineStart = null;
                this.splitLineEnd = null;
                this.splitLineType = 'free';
                this.setTool('split');
                this.selectedPolygon = null; // Clear selection on entry

                // Update button text
                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Execute Split';
                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f6ad55 0%, #ed8936 100%)';
                    btn.style.color = 'white';
                    btn.style.display = 'none'; // Only show when line is ready
                }

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'flex';

                this.updateSplitPrompt("Step 1: Click on the polygon you want to split.");
                this.selectedVertex = null;

                // Removed visual controls (Free, Horizontal, etc) as per user request
                // Defaulting to free split which is already set by this.splitLineType = 'free';

                this.render();
            }

            exitSplitMode() {
                this.splitMode = false;
                this.splitStep = 0;
                this.splitLineStart = null;
                this.splitLineEnd = null;

                const btn = document.querySelector('[data-tool="split"]');
                if (btn) {
                    btn.textContent = 'Split';
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.display = 'flex';
                }

                const confirmBtn = document.getElementById('splitConfirmSelectionBtn');
                if (confirmBtn) confirmBtn.style.display = 'none';

                const cancelBtn = document.getElementById('cancelSplitBtn');
                if (cancelBtn) cancelBtn.style.display = 'none';

                // No longer handling splitControls as they are not created

                const prompt = document.getElementById('splitPrompt');
                if (prompt) prompt.remove();

                this.render();
            }

            updateSplitPrompt(text) {
                let prompt = document.getElementById('splitPrompt');
                if (!prompt) {
                    prompt = document.createElement('div');
                    prompt.id = 'splitPrompt';
                    prompt.style.cssText = `
                        position: absolute;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: var(--color-primary-dark, #764ba2);
                        color: white;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 600;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                        z-index: 1000;
                        pointer-events: none;
                        white-space: nowrap;
                        animation: fadeIn 0.3s ease-out;
                    `;
                    document.querySelector('.canvas-container').appendChild(prompt);
                }
                prompt.textContent = text;
            }

            executeSplit() {
                if (!this.splitLineStart || !this.splitLineEnd) {
                    alert('Please draw a line to split polygons.');
                    return;
                }

                let splitHappened = false;
                const newPolygons = [];
                const toRemove = [];

                // If a polygon is selected, target it specifically
                // Otherwise, split any polygon intersected by the line
                const targetList = this.selectedPolygon ? [this.selectedPolygon] : this.polygons;

                for (let poly of targetList) {
                    if (!poly.visible) continue;

                    const pieces = PolygonBoolean.split(poly, this.splitLineStart, this.splitLineEnd);
                    if (pieces && pieces.length > 1) {
                        splitHappened = true;
                        toRemove.push(poly);

                        pieces.forEach((pts, idx) => {
                            const newPoly = new Polygon(pts, poly.color);
                            newPoly.name = `${poly.name} Part ${idx + 1}`;
                            newPolygons.push(newPoly);
                        });
                    }
                }

                if (splitHappened) {
                    this.polygons = this.polygons.filter(p => !toRemove.includes(p));
                    this.polygons.push(...newPolygons);

                    // Deselect the target polygon to avoid stale references
                    this.selectedPolygon = null;
                    this.selectedVertex = null;

                    this.saveHistory();
                    this.updateProperties();
                    this.updateLayers();
                    this.exitSplitMode();
                    this.setTool('select');
                } else {
                    alert('No polygons were intersected by the split line.');
                }
            }

            updateSplitLineConstraint(pos) {
                if (!this.splitLineStart) return;

                let newEnd = { ...pos };

                if (this.splitLineType === 'horizontal') {
                    newEnd.y = this.splitLineStart.y;
                } else if (this.splitLineType === 'vertical') {
                    newEnd.x = this.splitLineStart.x;
                } else if (this.splitLineType === 'diagonal') { // Optional: 45 degree snap? Or simply free/diagonal as requested
                    // If "Diagonal" implies 45 degrees specifically:
                    const dx = pos.x - this.splitLineStart.x;
                    const dy = pos.y - this.splitLineStart.y;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    // Snap to nearest 45
                    if (absDx > absDy) {
                        // Closer to horizontal, but force diagonal?
                        // Or just force 1:1 aspect ratio
                        newEnd.y = this.splitLineStart.y + Math.sign(dy) * absDx;
                    } else {
                        newEnd.x = this.splitLineStart.x + Math.sign(dx) * absDy;
                    }
                }

                this.splitLineEnd = newEnd;
            }

            // Canvas coordinate helpers
            screenToWorld(x, y) {
                return {
                    x: (x - this.canvas.width / 2 - this.pan.x) / this.zoom,
                    y: (y - this.canvas.height / 2 - this.pan.y) / this.zoom
                };
            }

            worldToScreen(x, y) {
                return {
                    x: x * this.zoom + this.canvas.width / 2 + this.pan.x,
                    y: y * this.zoom + this.canvas.height / 2 + this.pan.y
                };
            }

            snapToGrid(point) {
                if (!this.gridSnap) return point;
                return {
                    x: Math.round(point.x / this.gridSize) * this.gridSize,
                    y: Math.round(point.y / this.gridSize) * this.gridSize
                };
            }

            // Get the center of the current viewport in world coordinates, snapped to grid
            getViewportCenter() {
                // Center of canvas in screen coordinates
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Convert to world coordinates
                const worldCenter = this.screenToWorld(centerX, centerY);

                // Snap to grid
                return this.snapToGrid(worldCenter);
            }

            // Mouse/Touch handlers
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial click position for pan detection
                this.panStartPos = { x, y };

                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    // Middle button or shift+left for panning
                    this.isPanning = true;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                // Handle Split Mode Interaction
                if (this.splitMode && e.button === 0) {
                    if (this.splitStep === 0) {
                        // Step 0: Select Polygon
                        // Iterate backwards to pick top-most polygon
                        for (let i = this.polygons.length - 1; i >= 0; i--) {
                            const poly = this.polygons[i];
                            if (poly.visible && poly.containsPoint(snappedPos)) {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();

                                // Show confirmation pop-up
                                const confirmModal = document.getElementById('splitConfirmSelectionModal');
                                if (confirmModal) {
                                    confirmModal.style.display = 'flex';
                                }
                                return;
                            }
                        }
                    } else if (this.splitStep === 1) {
                        // Step 1: Start drawing line
                        this.isDragging = true;
                        this.dragStart = { x, y };
                        this.splitLineStart = snappedPos;
                        this.splitLineEnd = snappedPos;

                        // Show Execute button once drawing starts
                        const btn = document.querySelector('[data-tool="split"]');
                        if (btn) btn.style.display = 'flex';
                    }
                    return;
                }

                // Handle Combine Mode Selection
                if (this.combineMode && e.button === 0) {
                    // Iterate backwards for visual stacking (top first)
                    for (let i = this.polygons.length - 1; i >= 0; i--) {
                        const poly = this.polygons[i];
                        if (!poly.visible) continue;
                        if (poly.containsPoint(snappedPos)) {
                            if (this.combineSelection.has(poly)) {
                                this.combineSelection.delete(poly);
                            } else {
                                this.combineSelection.add(poly);
                            }
                            this.render();
                            this.updateLayers(); // Update sidebar to reflect selection
                            return;
                        }
                    }
                    return; // Don't do normal selection in combine mode
                }

                // Check if click is outside any polygon (for panning)
                const clickedOnPolygon = this.isPointOnPolygon(snappedPos);

                // If clicking outside polygons and using select tool, enable pan mode
                if (!clickedOnPolygon && this.currentTool === 'select' && e.button === 0) {
                    // Set up for potential panning - will activate on mousemove if threshold is met
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grab';
                    return;
                }

                switch (this.currentTool) {
                    case 'select':
                        this.handleSelect(snappedPos);
                        break;
                }
            }

            // Check if a point is on any polygon or vertex
            isPointOnPolygon(pos) {
                // Check for vertex selection first (higher priority)
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);
                        const threshold = Math.max(8, 20 / this.zoom);
                        if (distance < threshold) {
                            return true; // Clicked on a vertex
                        }
                    }
                }

                // Check for polygon selection
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (!poly.visible) continue;
                    if (poly.containsPoint(pos)) {
                        return true; // Clicked on a polygon
                    }
                }

                return false; // Clicked on empty space
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Update coordinate display
                document.getElementById('coordDisplay').textContent =
                    `X: ${Math.round(snappedPos.x)}, Y: ${Math.round(snappedPos.y)}`;

                // Handle Split Line Dragging
                if (this.splitMode && this.isDragging && this.splitStep === 1) {
                    if (this.splitLineStart) {
                        this.updateSplitLineConstraint(snappedPos);
                        this.render();
                    }
                    return;
                }

                // Handle panning (active pan or potential pan from empty space click)
                if (this.isPanning && this.dragStart) {
                    this.pan.x += x - this.dragStart.x;
                    this.pan.y += y - this.dragStart.y;
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grabbing';
                    this.render();
                    return;
                }

                // Check if we should start panning from empty space click
                if (this.panStartPos && this.dragStart && !this.isDragging && !this.isPanning &&
                    this.currentTool === 'select') {
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If moved beyond threshold, start panning
                    if (moveDistance > this.panThreshold) {
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grabbing';
                        // Deselect any selected polygon when starting to pan
                        if (this.selectedPolygon) {
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                        }
                    }
                }

                // Continue panning if we've started
                if (this.isPanning && this.dragStart) {
                    this.pan.x += x - this.dragStart.x;
                    this.pan.y += y - this.dragStart.y;
                    this.dragStart = { x, y };
                    this.render();
                    return;
                }

                if (this.isDragging && this.selectedVertex) {
                    // Update the vertex position
                    this.selectedVertex.x = snappedPos.x;
                    this.selectedVertex.y = snappedPos.y;

                    // Force reference breaking for this vertex array to be absolutely safe
                    if (this.selectedPolygon) {
                        this.selectedPolygon.vertices = this.selectedPolygon.vertices.map(v =>
                            v === this.selectedVertex ? this.selectedVertex : { x: v.x, y: v.y }
                        );
                    }

                    this.updateProperties();
                    this.render();
                } else if (this.isDragging && this.selectedPolygon && !this.selectedVertex) {
                    const dx = snappedPos.x - this.dragStart.x;
                    const dy = snappedPos.y - this.dragStart.y;
                    this.selectedPolygon.move(dx, dy);
                    this.dragStart = snappedPos;
                    this.updateProperties();
                    this.render();
                }
            }

            handleMouseUp(e) {
                // If we were panning, stop it
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // If we clicked but didn't pan (clicked on empty space without dragging)
                if (this.panStartPos && !this.isPanning && !this.isDragging && this.currentTool === 'select') {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // If we didn't move much, treat as a click to deselect
                    if (moveDistance <= this.panThreshold) {
                        const worldPos = this.screenToWorld(x, y);
                        const snappedPos = this.snapToGrid(worldPos);

                        // Only deselect if clicking on empty space
                        if (!this.isPointOnPolygon(snappedPos)) {
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        }
                    }
                }

                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
            }

            handleWheel(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const worldBefore = this.screenToWorld(x, y);

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom = Math.max(0.1, Math.min(5, this.zoom * delta));

                const worldAfter = this.screenToWorld(x, y);

                this.pan.x += (worldAfter.x - worldBefore.x) * this.zoom;
                this.pan.y += (worldAfter.y - worldBefore.y) * this.zoom;

                this.render();
            }

            handleDoubleClick(e) {
                // No double click actions
            }

            handleTouchStart(e) {
                e.preventDefault();

                // Handle multi-touch for pan/zoom
                if (e.touches.length === 2) {
                    this.isPinching = true;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    this.pinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.pinchZoom = this.zoom;
                    return;
                }

                // Single touch
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);
                const snappedPos = this.snapToGrid(worldPos);

                // Store initial touch position
                this.panStartPos = { x, y };

                // Check if touch is on a polygon
                const clickedOnPolygon = this.isPointOnPolygon(snappedPos);

                // If touching outside polygons and using select tool, enable pan mode
                if (!clickedOnPolygon && this.currentTool === 'select') {
                    this.dragStart = { x, y };
                    this.canvas.style.cursor = 'grab';
                    return;
                }

                // Convert to mouse event for other tools
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true
                });
                this.handleMouseDown(mouseEvent);
            }

            handleTouchMove(e) {
                e.preventDefault();

                // Handle pinch-to-zoom
                if (e.touches.length === 2 && this.isPinching) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    const scale = distance / this.pinchDistance;
                    this.zoom = Math.max(0.1, Math.min(5, this.pinchZoom * scale));
                    this.render();
                    return;
                }

                // Single touch move
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Check if we should start panning from empty space touch
                if (this.panStartPos && this.dragStart && !this.isDragging && !this.isPanning &&
                    this.currentTool === 'select') {
                    const moveDistance = Math.sqrt(
                        Math.pow(x - this.panStartPos.x, 2) +
                        Math.pow(y - this.panStartPos.y, 2)
                    );

                    // Lower threshold for touch (more sensitive)
                    if (moveDistance > this.panThreshold * 0.7) {
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grabbing';
                        // Deselect any selected polygon when starting to pan
                        if (this.selectedPolygon) {
                            this.selectedPolygon = null;
                            this.selectedVertex = null;
                            this.updateProperties();
                            this.updateLayers();
                        }
                    }
                }

                // Continue panning if active
                if (this.isPanning && this.dragStart) {
                    this.pan.x += x - this.dragStart.x;
                    this.pan.y += y - this.dragStart.y;
                    this.dragStart = { x, y };
                    this.render();
                    return;
                }

                // Otherwise handle as normal mouse move
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true
                });
                this.handleMouseMove(mouseEvent);
            }

            handleTouchEnd(e) {
                this.isPinching = false;

                // Handle touch end similar to mouse up
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = '';
                    this.updateCursor();
                }

                // If we clicked but didn't pan (touched empty space without dragging)
                if (this.panStartPos && !this.isPanning && !this.isDragging && this.currentTool === 'select') {
                    const touch = e.changedTouches[0];
                    if (touch) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        const moveDistance = Math.sqrt(
                            Math.pow(x - this.panStartPos.x, 2) +
                            Math.pow(y - this.panStartPos.y, 2)
                        );

                        // If we didn't move much, treat as a tap to deselect
                        if (moveDistance <= this.panThreshold * 0.7) {
                            const worldPos = this.screenToWorld(x, y);
                            const snappedPos = this.snapToGrid(worldPos);

                            // Only deselect if tapping on empty space
                            if (!this.isPointOnPolygon(snappedPos)) {
                                this.selectedPolygon = null;
                                this.selectedVertex = null;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();
                            }
                        }
                    }
                }

                if (this.isDragging && (this.selectedVertex || this.selectedPolygon)) {
                    this.saveHistory();
                }

                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = null;
                this.panStartPos = null;
            }

            handleKeyDown(e) {
                // Quick shape creation shortcuts when menu is open
                if (this.shapeMenuOpen) {
                    const shortcutMap = {
                        't': 'triangle',
                        's': 'square',
                        'r': 'rectangle',
                        'p': 'pentagon',
                        'h': 'hexagon',
                        '7': 'heptagon',
                        'o': 'octagon'
                    };

                    const key = e.key.toLowerCase();
                    if (shortcutMap[key]) {
                        e.preventDefault();
                        const option = document.querySelector(`[data-shape="${shortcutMap[key]}"]`);
                        if (option) this.selectShape(option);
                        return;
                    }
                }

                switch (e.key.toLowerCase()) {
                    case 's':
                        if (!e.ctrlKey && !this.shapeMenuOpen) this.setTool('select');
                        break;
                    case 'z':
                        if (e.ctrlKey) this.undo();
                        break;
                    case 'y':
                        if (e.ctrlKey) this.redo();
                        break;
                    case 'delete':
                        this.deleteSelected();
                        break;
                    case 'escape':
                        this.cancelCurrentAction();
                        break;
                    case ' ':
                        e.preventDefault();
                        this.isPanning = true;
                        this.canvas.style.cursor = 'grab';
                        break;
                }
            }

            handleKeyUp(e) {
                if (e.key === ' ') {
                    this.isPanning = false;
                    this.updateCursor();
                }
            }

            handleSelect(pos) {
                this.selectedVertex = null;
                this.selectedPolygon = null;

                // Check for vertex selection first (higher priority)
                // Iterate backwards to select from top-most polygons first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    for (let j = 0; j < poly.vertices.length; j++) {
                        const vertex = poly.vertices[j];
                        const distance = this.distance(pos, vertex);

                        // Make sure we're using a reasonable threshold that works at all zoom levels
                        // Use a dynamic threshold that's large enough to be easily clickable
                        const threshold = Math.max(8, 20 / this.zoom);

                        if (distance < threshold) {
                            this.selectedPolygon = poly;
                            this.selectedVertex = vertex;
                            this.isDragging = true;
                            this.dragStart = pos;
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                            return;
                        }
                    }
                }

                // Check for polygon selection
                // Iterate backwards to select top-most polygon first
                for (let i = this.polygons.length - 1; i >= 0; i--) {
                    const poly = this.polygons[i];
                    if (poly.containsPoint(pos)) {
                        this.selectedPolygon = poly;
                        this.isDragging = true;
                        this.dragStart = pos;
                        this.updateProperties();
                        this.updateLayers();
                        this.render();
                        return;
                    }
                }

                this.updateProperties();
                this.updateLayers();
                this.render();
            }

            // Geometry calculations
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            // UI Updates
            updateCursor() {
                // Don't override grab/grabbing cursors during panning
                if (this.isPanning) {
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }

                const cursors = {
                    'select': 'default',
                };
                this.canvas.style.cursor = cursors[this.currentTool] || 'default';
            }

            updateProperties() {
                const panel = document.getElementById('propertiesPanelContent');

                if (!this.selectedPolygon) {
                    panel.innerHTML = '<div class="property-row"><span class="property-label">Select a polygon</span></div>';
                    return;
                }

                const areaPx = Math.abs(this.selectedPolygon.getArea());
                const perimeterPx = this.selectedPolygon.getPerimeter();

                const area = areaPx / (this.gridSize * this.gridSize);
                const perimeter = perimeterPx / this.gridSize;
                const vertices = this.selectedPolygon.vertices.length;

                let html = `
            <div class="property-row">
                <span class="property-label">Name:</span>
                <span class="property-value">${this.selectedPolygon.name}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Vertices:</span>
                <span class="property-value">${vertices}</span>
            </div>
            <div class="property-row">
                <span class="property-label">Perimeter:</span>
                <span class="property-value">${perimeter.toFixed(2)} units</span>
            </div>
            <div class="property-row">
                <span class="property-label">Area:</span>
                <span class="property-value">${area.toFixed(2)} sq units</span>
            </div>
        `;

                // Add triangle classifier if it's a triangle
                if (vertices === 3) {
                    const classification = this.classifyTriangle(this.selectedPolygon);
                    html += `
                <div class="triangle-classifier">
                    <div style="font-weight: 600; margin-bottom: 8px;">Triangle Type:</div>
                    <span class="classifier-badge">${classification.sides}</span>
                    <span class="classifier-badge">${classification.angles}</span>
                </div>
            `;
                }

                panel.innerHTML = html;
            }

            updateLayers() {
                const list = document.getElementById('layersList');
                document.getElementById('layerCount').textContent = this.polygons.length;

                list.innerHTML = '';
                this.polygons.forEach((poly, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (!this.combineMode && poly === this.selectedPolygon)) {
                        item.classList.add('selected');
                    }

                    item.innerHTML = `
                <div class="layer-color" style="background: ${poly.color}"></div>
                <div class="layer-name">${poly.name}</div>
                <div class="layer-actions">
                    <button class="layer-action-btn" onclick="app.togglePolygonVisibility(${index})" title="${poly.visible ? 'Hide' : 'Show'}">
                        ${poly.visible
                            ? 'üëÅÔ∏è'
                            : '<div style="position:relative; display:inline-block;">üëÅÔ∏è<div style="position:absolute; top:50%; left:-2px; right:-2px; height:2px; background:red; transform:rotate(-45deg); pointer-events:none;"></div></div>'}
                    </button>
                    <button class="layer-action-btn" onclick="app.deletePolygon(${index})" title="Delete">üóëÔ∏è</button>
                </div>
            `;

                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('layer-action-btn')) {
                            if (this.combineMode) {
                                if (this.combineSelection.has(poly)) {
                                    this.combineSelection.delete(poly);
                                } else {
                                    this.combineSelection.add(poly);
                                }
                                this.render();
                                this.updateLayers();
                            } else {
                                this.selectedPolygon = poly;
                                this.updateProperties();
                                this.updateLayers();
                                this.render();
                            }
                        }
                    });

                    list.appendChild(item);
                });
            }

            classifyTriangle(polygon) {
                const v = polygon.vertices;
                if (v.length !== 3) return null;

                // Calculate side lengths
                const sides = [
                    this.distance(v[0], v[1]),
                    this.distance(v[1], v[2]),
                    this.distance(v[2], v[0])
                ];

                // Classify by sides
                let sideType;
                const tolerance = 1;
                if (Math.abs(sides[0] - sides[1]) < tolerance &&
                    Math.abs(sides[1] - sides[2]) < tolerance) {
                    sideType = 'Equilateral';
                } else if (Math.abs(sides[0] - sides[1]) < tolerance ||
                    Math.abs(sides[1] - sides[2]) < tolerance ||
                    Math.abs(sides[0] - sides[2]) < tolerance) {
                    sideType = 'Isosceles';
                } else {
                    sideType = 'Scalene';
                }

                // Calculate angles
                const angles = [];
                for (let i = 0; i < 3; i++) {
                    const v1 = v[i];
                    const v2 = v[(i + 1) % 3];
                    const v3 = v[(i + 2) % 3];

                    const a = this.distance(v2, v3);
                    const b = this.distance(v1, v3);
                    const c = this.distance(v1, v2);

                    const angle = Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI;
                    angles.push(angle);
                }

                // Classify by angles
                let angleType;
                if (angles.some(a => Math.abs(a - 90) < 1)) {
                    angleType = 'Right';
                } else if (angles.some(a => a > 90)) {
                    angleType = 'Obtuse';
                } else {
                    angleType = 'Acute';
                }

                return { sides: sideType, angles: angleType };
            }

            // Rendering
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Save context state
                this.ctx.save();

                // Apply transformations
                this.ctx.translate(this.canvas.width / 2 + this.pan.x, this.canvas.height / 2 + this.pan.y);
                this.ctx.scale(this.zoom, this.zoom);

                // Draw grid
                this.drawGrid();

                // Draw visualizers
                if (this.visualizers.size > 0 && this.selectedPolygon) {
                    this.drawVisualizers();
                }

                // Draw polygons
                for (let poly of this.polygons) {
                    if (!poly.visible) continue;
                    let isSelected = poly === this.selectedPolygon;

                    // Highlight polygons selected for combination OR the primary selection in Split mode
                    if ((this.combineMode && this.combineSelection.has(poly)) ||
                        (this.splitMode && poly === this.selectedPolygon)) {
                        this.ctx.save();
                        this.ctx.shadowColor = '#ed8936'; // Orange/Gold glow
                        this.ctx.shadowBlur = 15;
                        this.drawPolygon(poly, true);
                        this.ctx.restore();
                    } else {
                        this.drawPolygon(poly, isSelected);
                    }
                }

                // Draw Split Line
                if (this.splitMode && this.splitLineStart && this.splitLineEnd) {
                    this.ctx.save();
                    this.ctx.strokeStyle = '#e53e3e';
                    this.ctx.lineWidth = 2 / this.zoom;
                    this.ctx.setLineDash([5 / this.zoom, 5 / this.zoom]);

                    // Calculate extended line for visualization if needed, or just segment
                    // Let's draw the segment for now as the "vector"
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.splitLineStart.x, this.splitLineStart.y);
                    this.ctx.lineTo(this.splitLineEnd.x, this.splitLineEnd.y);
                    this.ctx.stroke();

                    // Draw endpoints
                    this.ctx.fillStyle = '#e53e3e';
                    this.ctx.beginPath();
                    this.ctx.arc(this.splitLineStart.x, this.splitLineStart.y, 4 / this.zoom, 0, Math.PI * 2);
                    this.ctx.arc(this.splitLineEnd.x, this.splitLineEnd.y, 4 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.restore();
                }

                this.ctx.restore();
            }

            drawGrid() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1 / this.zoom;

                const viewBounds = {
                    left: -this.canvas.width / (2 * this.zoom) - this.pan.x / this.zoom,
                    right: this.canvas.width / (2 * this.zoom) - this.pan.x / this.zoom,
                    top: -this.canvas.height / (2 * this.zoom) - this.pan.y / this.zoom,
                    bottom: this.canvas.height / (2 * this.zoom) - this.pan.y / this.zoom
                };

                // Draw vertical lines
                const startX = Math.floor(viewBounds.left / this.gridSize) * this.gridSize;
                const endX = Math.ceil(viewBounds.right / this.gridSize) * this.gridSize;

                for (let x = startX; x <= endX; x += this.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, viewBounds.top);
                    this.ctx.lineTo(x, viewBounds.bottom);
                    this.ctx.stroke();
                }

                // Draw horizontal lines
                const startY = Math.floor(viewBounds.top / this.gridSize) * this.gridSize;
                const endY = Math.ceil(viewBounds.bottom / this.gridSize) * this.gridSize;

                for (let y = startY; y <= endY; y += this.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(viewBounds.left, y);
                    this.ctx.lineTo(viewBounds.right, y);
                    this.ctx.stroke();
                }

                // Draw axes
                this.ctx.strokeStyle = '#999';
                this.ctx.lineWidth = 2 / this.zoom;

                // X-axis
                this.ctx.beginPath();
                this.ctx.moveTo(viewBounds.left, 0);
                this.ctx.lineTo(viewBounds.right, 0);
                this.ctx.stroke();

                // Y-axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, viewBounds.top);
                this.ctx.lineTo(0, viewBounds.bottom);
                this.ctx.stroke();
            }

            drawPolygon(polygon, selected = false) {
                const vertices = polygon.vertices;
                if (vertices.length < 2) return;

                // Draw fill
                this.ctx.fillStyle = polygon.color + '33';
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Draw stroke
                this.ctx.strokeStyle = selected ? '#333' : polygon.color;
                this.ctx.lineWidth = (selected ? 3 : 2) / this.zoom;
                this.ctx.stroke();

                // Draw vertices
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];

                    // Normal vertex rendering - enhanced for better dragging visibility
                    let vertexSize = selected ? 8 : 4;
                    let vertexFill = selected ? '#fff' : polygon.color;
                    let vertexStroke = selected ? '#333' : polygon.color;

                    // Make vertex larger when it's being dragged
                    if (this.selectedVertex === v) {
                        vertexSize = selected ? 10 : 6;
                    }

                    this.ctx.fillStyle = vertexFill;
                    this.ctx.strokeStyle = vertexStroke;
                    this.ctx.lineWidth = 2 / this.zoom;

                    this.ctx.beginPath();
                    this.ctx.arc(v.x, v.y, vertexSize / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }

            drawVisualizers() {
                const poly = this.selectedPolygon;
                if (!poly || poly.vertices.length < 3) return;

                this.ctx.save();

                // Angles
                if (this.visualizers.has('angles')) {
                    this.ctx.font = `bold ${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];
                        const v3 = poly.vertices[(i + 2) % poly.vertices.length];

                        const a = this.distance(v2, v3); // Side from v2 to v3 (Adjacent 1)
                        const b = this.distance(v1, v3); // Side from v1 to v3 (Opposite to v2)
                        const c = this.distance(v1, v2); // Side from v1 to v2 (Adjacent 2)

                        // Law of Cosines for Angle at v2: b¬≤ = a¬≤ + c¬≤ - 2ac cos(Angle)
                        // cos(Angle) = (a¬≤ + c¬≤ - b¬≤) / (2ac)
                        let numerator = a * a + c * c - b * b;
                        let denominator = 2 * a * c;

                        // Avoid division by zero
                        if (denominator === 0) continue;

                        let cosAngle = numerator / denominator;
                        // Clamp to [-1, 1] to handle float precision issues
                        cosAngle = Math.max(-1, Math.min(1, cosAngle));

                        const angle = Math.acos(cosAngle) * 180 / Math.PI;

                        // Calculate Bisector Vector for positioning
                        // Vector v2->v1
                        let dx1 = v1.x - v2.x;
                        let dy1 = v1.y - v2.y;
                        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        if (len1 > 0) { dx1 /= len1; dy1 /= len1; }

                        // Vector v2->v3
                        let dx3 = v3.x - v2.x;
                        let dy3 = v3.y - v2.y;
                        const len3 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
                        if (len3 > 0) { dx3 /= len3; dy3 /= len3; }

                        // Bisector (Approximate inward direction for angle <= 180)
                        let bx = dx1 + dx3;
                        let by = dy1 + dy3;
                        const bLen = Math.sqrt(bx * bx + by * by);
                        if (bLen > 0) { bx /= bLen; by /= bLen; }

                        // Offset distance (Inward)
                        const offset = 35 / this.zoom;
                        const labelX = v2.x + bx * offset;
                        const labelY = v2.y + by * offset;

                        // Draw Badge
                        const text = `${angle.toFixed(0)}¬∞`;
                        // Fixed radius circle usually fits 2-3 digits well enough at this font size
                        // Radius 12 fits nicely
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 13 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#ff6b6b';
                        this.ctx.stroke();

                        this.ctx.fillStyle = '#ff6b6b';
                        this.ctx.fillText(text, labelX, labelY);
                    }
                }

                // Medians & Centroid (for triangles)
                if (this.visualizers.has('medians') && poly.vertices.length === 3) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    const centroid = {
                        x: (poly.vertices[0].x + poly.vertices[1].x + poly.vertices[2].x) / 3,
                        y: (poly.vertices[0].y + poly.vertices[1].y + poly.vertices[2].y) / 3
                    };

                    for (let i = 0; i < 3; i++) {
                        const v = poly.vertices[i];
                        const opposite1 = poly.vertices[(i + 1) % 3];
                        const opposite2 = poly.vertices[(i + 2) % 3];
                        const midpoint = {
                            x: (opposite1.x + opposite2.x) / 2,
                            y: (opposite1.y + opposite2.y) / 2
                        };

                        this.ctx.beginPath();
                        this.ctx.moveTo(v.x, v.y);
                        this.ctx.lineTo(midpoint.x, midpoint.y);
                        this.ctx.stroke();
                    }

                    this.ctx.setLineDash([]);
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.beginPath();
                    this.ctx.arc(centroid.x, centroid.y, 5 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Diagonals
                if (this.visualizers.has('diagonals') && poly.vertices.length > 3) {
                    this.ctx.strokeStyle = '#a855f7';
                    this.ctx.lineWidth = 1 / this.zoom;
                    this.ctx.setLineDash([4 / this.zoom, 4 / this.zoom]);

                    for (let i = 0; i < poly.vertices.length; i++) {
                        for (let j = i + 2; j < poly.vertices.length; j++) {
                            if (j === poly.vertices.length - 1 && i === 0) continue;

                            this.ctx.beginPath();
                            this.ctx.moveTo(poly.vertices[i].x, poly.vertices[i].y);
                            this.ctx.lineTo(poly.vertices[j].x, poly.vertices[j].y);
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.setLineDash([]);
                }

                // Show Vertices (ABC points)
                if (this.visualizers.has('vertices')) {
                    this.ctx.font = `bold ${16 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    // Calculate centroid
                    let cx = 0, cy = 0;
                    if (poly.vertices.length > 0) {
                        for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                        cx /= poly.vertices.length;
                        cy /= poly.vertices.length;
                    }

                    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v = poly.vertices[i];
                        const letter = letters[i % letters.length];

                        // Calculate outward direction
                        let dx = v.x - cx;
                        let dy = v.y - cy;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len > 0) {
                            dx /= len;
                            dy /= len;
                        }

                        // Offset: Vertex Radius (approx 5) + padding
                        const dist = 20 / this.zoom;
                        const labelX = v.x + dx * dist;
                        const labelY = v.y + dy * dist;

                        // Draw Background Badge (White Circle)
                        this.ctx.beginPath();
                        this.ctx.arc(labelX, labelY, 10 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fill();
                        this.ctx.lineWidth = 1 / this.zoom;
                        this.ctx.strokeStyle = '#10b981';
                        this.ctx.stroke();

                        // Draw Letter
                        this.ctx.fillStyle = '#10b981';
                        this.ctx.fillText(letter, labelX, labelY);
                    }
                }

                // Show Perimeters
                if (this.visualizers.has('perimeters')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;
                    this.ctx.strokeStyle = '#0d9488'; // Teal
                    this.ctx.fillStyle = '#0d9488'; // Teal

                    // Calculate centroid for outward direction check
                    let cx = 0, cy = 0;
                    for (let v of poly.vertices) { cx += v.x; cy += v.y; }
                    cx /= poly.vertices.length;
                    cy /= poly.vertices.length;

                    for (let i = 0; i < poly.vertices.length; i++) {
                        const v1 = poly.vertices[i];
                        const v2 = poly.vertices[(i + 1) % poly.vertices.length];

                        // Calculate grid length
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        const distance = len / this.gridSize;

                        // Calculate offset vector (perpendicular to edge)
                        const angle = Math.atan2(dy, dx);
                        const offsetX = Math.sin(angle) * (15 / this.zoom);
                        const offsetY = -Math.cos(angle) * (15 / this.zoom);

                        const midX = (v1.x + v2.x) / 2;
                        const midY = (v1.y + v2.y) / 2;

                        // Check if offset is outward or inward compared to centroid
                        const distOut = (midX + offsetX - cx) ** 2 + (midY + offsetY - cy) ** 2;
                        const distIn = (midX - offsetX - cx) ** 2 + (midY - offsetY - cy) ** 2;

                        const actualOffsetX = distOut > distIn ? offsetX : -offsetX;
                        const actualOffsetY = distOut > distIn ? offsetY : -offsetY;

                        // Draw Bracket
                        this.ctx.beginPath();
                        // Main line
                        this.ctx.moveTo(v1.x + actualOffsetX, v1.y + actualOffsetY);
                        this.ctx.lineTo(v2.x + actualOffsetX, v2.y + actualOffsetY);

                        // End caps (small ticks)
                        const tickX = Math.cos(angle) * (4 / this.zoom);
                        const tickY = Math.sin(angle) * (4 / this.zoom);

                        this.ctx.moveTo(v1.x + actualOffsetX + tickX, v1.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v1.x + actualOffsetX - tickX, v1.y + actualOffsetY - tickY);

                        this.ctx.moveTo(v2.x + actualOffsetX + tickX, v2.y + actualOffsetY + tickY);
                        this.ctx.lineTo(v2.x + actualOffsetX - tickX, v2.y + actualOffsetY - tickY);

                        this.ctx.stroke();

                        // Label
                        this.ctx.fillText(`${distance.toFixed(1)}`, midX + actualOffsetX * 1.8, midY + actualOffsetY * 1.8);
                    }
                }

                // Show Base & Height
                if (this.visualizers.has('baseHeight')) {
                    this.ctx.font = `${14 / this.zoom}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.lineWidth = 1.5 / this.zoom;

                    const vertices = poly.vertices;

                    if (vertices.length === 3) {
                        // Triangle Logic: Find the "best" base (closest to horizontal bottom)
                        let bestSideIndex = -1;
                        let maxHorizontalScore = -Infinity;

                        for (let i = 0; i < 3; i++) {
                            const v1 = vertices[i];
                            const v2 = vertices[(i + 1) % 3];
                            const dx = Math.abs(v2.x - v1.x);
                            const dy = Math.abs(v2.y - v1.y);
                            const length = Math.sqrt(dx * dx + dy * dy);

                            // Score: Prefer horizontal (small dy) and lower (large y)
                            // We weigh horizontal alignment heavily
                            const horizontalness = dx / (length + 0.001); // 0 to 1
                            const avgY = (v1.y + v2.y) / 2;

                            // Simple heuristic: Horizontalness is king, then lower Y
                            const score = horizontalness * 1000 + avgY;

                            if (score > maxHorizontalScore) {
                                maxHorizontalScore = score;
                                bestSideIndex = i;
                            }
                        }

                        const i = bestSideIndex;
                        const baseV1 = vertices[i];
                        const baseV2 = vertices[(i + 1) % 3];
                        const apex = vertices[(i + 2) % 3];

                        // Calculate geometric base length
                        const baseLength = this.distance(baseV1, baseV2) / this.gridSize;

                        // Calculate geometric height (distance from apex to base line)
                        // Area = 0.5 * base * height => Height = 2 * Area / Base
                        // Use signed area formula for polygon area
                        const area = Math.abs(poly.getArea());
                        // Wait, poly.getArea() returns area in square grid units (roughly), 
                        // let's trust geometric calculation

                        // Recalculate physical area using coordinates for precision
                        const physicalArea = Math.abs((baseV1.x * (baseV2.y - apex.y) + baseV2.x * (apex.y - baseV1.y) + apex.x * (baseV1.y - baseV2.y)) / 2);
                        const physicalBase = this.distance(baseV1, baseV2);
                        const physicalHeight = (2 * physicalArea) / physicalBase;
                        const heightLength = physicalHeight / this.gridSize;

                        // Draw Base Bracket
                        this.ctx.strokeStyle = '#2563eb'; // Blue for Base
                        this.ctx.fillStyle = '#2563eb';

                        // Offset for bracket
                        const angle = Math.atan2(baseV2.y - baseV1.y, baseV2.x - baseV1.x);
                        const offsetX = Math.sin(angle) * (20 / this.zoom);
                        const offsetY = -Math.cos(angle) * (20 / this.zoom);

                        // If offset points *into* the triangle, flip it
                        // Check midpoint + offset vs centroid
                        const midX = (baseV1.x + baseV2.x) / 2;
                        const midY = (baseV1.y + baseV2.y) / 2;
                        const centroidX = (baseV1.x + baseV2.x + apex.x) / 3;
                        const centroidY = (baseV1.y + baseV2.y + apex.y) / 3;

                        const valOriginal = (midX + offsetX - centroidX) ** 2 + (midY + offsetY - centroidY) ** 2;
                        const valFlipped = (midX - offsetX - centroidX) ** 2 + (midY - offsetY - centroidY) ** 2;

                        const actualOffsetX = valOriginal > valFlipped ? offsetX : -offsetX;
                        const actualOffsetY = valOriginal > valFlipped ? offsetY : -offsetY;

                        // Draw Bracket Line
                        this.ctx.beginPath();
                        this.ctx.moveTo(baseV1.x + actualOffsetX, baseV1.y + actualOffsetY);
                        this.ctx.lineTo(baseV2.x + actualOffsetX, baseV2.y + actualOffsetY);
                        this.ctx.stroke();

                        // Label Base
                        this.ctx.fillText(`b = ${baseLength.toFixed(1)}`, midX + actualOffsetX * 1.5, midY + actualOffsetY * 1.5);


                        // Draw Height Line
                        this.ctx.strokeStyle = '#dc2626'; // Red for Height
                        this.ctx.fillStyle = '#dc2626';
                        this.ctx.setLineDash([5 / this.zoom, 3 / this.zoom]);

                        // Project apex onto base line
                        // Line defined by baseV1 + t * (baseV2 - baseV1)
                        const dx = baseV2.x - baseV1.x;
                        const dy = baseV2.y - baseV1.y;
                        const t = ((apex.x - baseV1.x) * dx + (apex.y - baseV1.y) * dy) / (dx * dx + dy * dy);

                        const projX = baseV1.x + t * dx;
                        const projY = baseV1.y + t * dy;

                        this.ctx.beginPath();
                        this.ctx.moveTo(apex.x, apex.y);
                        this.ctx.lineTo(projX, projY);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);

                        // Label Height
                        const hMidX = (apex.x + projX) / 2;
                        const hMidY = (apex.y + projY) / 2;
                        this.ctx.fillText(`h = ${heightLength.toFixed(1)}`, hMidX + 10 / this.zoom, hMidY);

                        // Draw Right Angle mark at projection
                        const size = 10 / this.zoom;
                        // Need vector along base line
                        const baseLen = Math.sqrt(dx * dx + dy * dy);
                        const ux = dx / baseLen;
                        const uy = dy / baseLen;
                        // Vector along height line
                        const hx = apex.x - projX;
                        const hy = apex.y - projY;
                        // Perpendicular check not strictly needed for drawing box, just use base direction

                        // We draw a small box at projX,projY aligned with base
                        // This is tricky on general angles, skipping for simplicity or just drawing a dot
                        this.ctx.beginPath();
                        this.ctx.arc(projX, projY, 3 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fill();

                    } else {
                        // Bounding Box Logic for other polygons
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        vertices.forEach(v => {
                            minX = Math.min(minX, v.x);
                            maxX = Math.max(maxX, v.x);
                            minY = Math.min(minY, v.y);
                            maxY = Math.max(maxY, v.y);
                        });

                        const width = (maxX - minX) / this.gridSize;
                        const height = (maxY - minY) / this.gridSize;

                        this.ctx.strokeStyle = '#2563eb';
                        this.ctx.fillStyle = '#2563eb';

                        // Width label (Bottom)
                        this.ctx.beginPath();
                        this.ctx.moveTo(minX, maxY + 20 / this.zoom);
                        this.ctx.lineTo(maxX, maxY + 20 / this.zoom);
                        this.ctx.stroke();
                        this.ctx.fillText(`w = ${width.toFixed(1)}`, (minX + maxX) / 2, maxY + 35 / this.zoom);

                        this.ctx.strokeStyle = '#dc2626';
                        this.ctx.fillStyle = '#dc2626';

                        // Height label (Right)
                        this.ctx.beginPath();
                        this.ctx.moveTo(maxX + 20 / this.zoom, minY);
                        this.ctx.lineTo(maxX + 20 / this.zoom, maxY);
                        this.ctx.stroke();
                        this.ctx.fillText(`h = ${height.toFixed(1)}`, maxX + 35 / this.zoom, (minY + maxY) / 2);
                    }
                }

                this.ctx.restore();
            }

            getMouseWorldPos() {
                // Get current mouse position in world coordinates
                // This is a simplified version - would need actual mouse tracking
                return null;
            }

            // Utility functions
            setTool(tool) {

                document.querySelectorAll('[data-tool]').forEach(btn => {
                    if (btn.dataset.tool === tool) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.currentTool = tool;
                this.updateCursor();
                this.render();
            }

            toggleGridSnap() {
                this.gridSnap = !this.gridSnap;
                const toggle = document.getElementById('gridSnapToggle');
                toggle.classList.toggle('active');
            }

            togglePolygonVisibility(index) {
                if (this.polygons[index]) {
                    this.polygons[index].visible = !this.polygons[index].visible;
                    this.saveHistory();
                    this.render();
                    this.updateLayers();
                }
            }

            deletePolygon(index) {
                if (this.polygons[index]) {
                    if (this.selectedPolygon === this.polygons[index]) {
                        this.selectedPolygon = null;
                    }
                    this.polygons.splice(index, 1);
                    this.saveHistory();
                    this.updateProperties();
                    this.updateLayers();
                    this.render();
                }
            }

            deleteSelected() {
                if (this.selectedPolygon) {
                    const index = this.polygons.indexOf(this.selectedPolygon);
                    if (index !== -1) {
                        this.deletePolygon(index);
                    }
                }
            }

            cancelCurrentAction() {
                this.isDragging = false;
                this.selectedVertex = null;
                this.dragStart = null;
                this.render();
            }

            // History management
            saveHistory() {
                const state = JSON.stringify(this.polygons.map(p => ({
                    vertices: p.vertices,
                    color: p.color,
                    name: p.name,
                    visible: p.visible
                })));

                // Avoid redundant saves if state hasn't changed
                if (this.historyIndex >= 0 && state === this.history[this.historyIndex]) {
                    return;
                }

                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex++;

                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.cancelCurrentAction();
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.cancelCurrentAction();
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            loadState(state) {
                // Store current selection index to restore it if possible
                const selectedIndex = this.selectedPolygon ? this.polygons.indexOf(this.selectedPolygon) : -1;

                const data = JSON.parse(state);
                this.polygons = data.map(p => {
                    const poly = new Polygon(p.vertices, p.color);
                    poly.name = p.name;
                    poly.visible = p.visible;
                    return poly;
                });

                // Restore selection if index is still valid
                if (selectedIndex >= 0 && selectedIndex < this.polygons.length) {
                    this.selectedPolygon = this.polygons[selectedIndex];
                } else {
                    this.selectedPolygon = null;
                }

                this.updateProperties();
                this.updateLayers();
                this.render();
            }

            // Zoom functions
            zoomIn() {
                this.zoom = Math.min(5, this.zoom * 1.2);
                this.render();
            }

            zoomOut() {
                this.zoom = Math.max(0.1, this.zoom / 1.2);
                this.render();
            }

            zoomReset() {
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.render();
            }

            // Save/Load
            save() {
                const data = {
                    polygons: this.polygons.map(p => ({
                        vertices: p.vertices,
                        color: p.color,
                        name: p.name
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'geometry-playground.json';
                a.click();

                URL.revokeObjectURL(url);
            }

            load() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.polygons = data.polygons.map(p => {
                                const poly = new Polygon(p.vertices, p.color);
                                poly.name = p.name;
                                return poly;
                            });

                            this.selectedPolygon = null;
                            this.saveHistory();
                            this.updateProperties();
                            this.updateLayers();
                            this.render();
                        } catch (error) {
                            alert('Error loading file: ' + error.message);
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            }

            reset() {
                const modal = document.getElementById('resetModal');
                if (modal) {
                    modal.style.display = 'flex';
                }
            }

            executeReset() {
                // Exit any active modes
                if (this.combineMode) this.exitCombineMode();
                if (this.splitMode) this.exitSplitMode();

                // switch to select tool to ensure UI is consistent
                this.setTool('select');

                this.polygons = [];
                this.selectedPolygon = null;
                this.selectedVertex = null;
                this.history = [];
                this.historyIndex = -1;
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };

                this.createSamplePolygon();
                this.updateProperties(); // Clear properties panel
                this.updateLayers();
                this.render();
            }

            highlightConcept(concept) {
                // Visual feedback when learning concepts are clicked
                // Could be expanded to show specific examples on canvas
                console.log('Highlighting concept:', concept);
            }
        }

        // Polygon class
        class Polygon {
            constructor(vertices = [], color = '#667eea') {
                // Always create new point objects to ensure independence from other polygons
                this.vertices = vertices.map(v => ({ x: v.x, y: v.y }));
                this.color = color;
                this.name = 'Polygon';
                this.visible = true;
            }

            containsPoint(point) {
                let inside = false;
                const vertices = this.vertices;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;

                    const intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }

                return inside;
            }

            getArea() {
                // Shoelace formula
                let area = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += this.vertices[i].x * this.vertices[j].y;
                    area -= this.vertices[j].x * this.vertices[i].y;
                }

                return Math.abs(area / 2);
            }

            getPerimeter() {
                let perimeter = 0;
                const n = this.vertices.length;

                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    const dx = this.vertices[j].x - this.vertices[i].x;
                    const dy = this.vertices[j].y - this.vertices[i].y;
                    perimeter += Math.sqrt(dx * dx + dy * dy);
                }

                return perimeter;
            }

            move(dx, dy) {
                // Create new objects for vertices to break any shared references
                this.vertices = this.vertices.map(v => ({
                    x: v.x + dx,
                    y: v.y + dy
                }));
            }
        }

        // Mobile menu toggle functionality
        function toggleMobileSidebar(sidebar) {
            if (deviceDetector && deviceDetector.getInfo().isMobile) {
                sidebar.classList.toggle('mobile-open');

                // Update backdrop
                const backdrop = document.getElementById('sidebarBackdrop');
                if (backdrop) {
                    if (sidebar.classList.contains('mobile-open')) {
                        backdrop.classList.add('active');
                        backdrop.addEventListener('click', closeMobileSidebars);
                    } else {
                        backdrop.classList.remove('active');
                        backdrop.removeEventListener('click', closeMobileSidebars);
                    }
                }

                // Close other sidebars
                document.querySelectorAll('.sidebar').forEach(s => {
                    if (s !== sidebar) {
                        s.classList.remove('mobile-open');
                    }
                });
            }
        }

        function closeMobileSidebars() {
            document.querySelectorAll('.sidebar').forEach(s => {
                s.classList.remove('mobile-open');
            });
            const backdrop = document.getElementById('sidebarBackdrop');
            if (backdrop) {
                backdrop.classList.remove('active');
                backdrop.removeEventListener('click', closeMobileSidebars);
            }
        }

        // Add mobile menu buttons if needed
        function setupMobileMenus() {
            if (deviceDetector && deviceDetector.getInfo().isMobile) {
                // Add menu toggle buttons to canvas container
                const canvasContainer = document.getElementById('canvasContainer');

                // Left sidebar toggle
                if (!document.getElementById('mobileMenuLeft')) {
                    const leftToggle = document.createElement('button');
                    leftToggle.id = 'mobileMenuLeft';
                    leftToggle.className = 'mobile-menu-toggle';
                    leftToggle.innerHTML = '‚ò∞';
                    leftToggle.style.cssText = `
                position: absolute;
                top: 12px;
                left: 12px;
                width: 44px;
                height: 44px;
                z-index: 1001;
                background: white;
                border: none;
                border-radius: 8px;
                font-size: 20px;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            `;
                    leftToggle.addEventListener('click', () => {
                        const sidebar = document.querySelector('.sidebar:not(.sidebar-right)');
                        if (sidebar) toggleMobileSidebar(sidebar);
                    });
                    canvasContainer.appendChild(leftToggle);
                }

                // Right sidebar toggle
                if (!document.getElementById('mobileMenuRight')) {
                    const rightToggle = document.createElement('button');
                    rightToggle.id = 'mobileMenuRight';
                    rightToggle.className = 'mobile-menu-toggle';
                    rightToggle.innerHTML = '‚öôÔ∏è';
                    rightToggle.style.cssText = `
                position: absolute;
                top: 12px;
                right: 12px;
                width: 44px;
                height: 44px;
                z-index: 1001;
                background: white;
                border: none;
                border-radius: 8px;
                font-size: 20px;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            `;
                    rightToggle.addEventListener('click', () => {
                        const sidebar = document.querySelector('.sidebar-right');
                        if (sidebar) toggleMobileSidebar(sidebar);
                    });
                    canvasContainer.appendChild(rightToggle);
                }
            } else {
                // Remove mobile menu buttons on desktop
                const leftToggle = document.getElementById('mobileMenuLeft');
                const rightToggle = document.getElementById('mobileMenuRight');
                if (leftToggle) leftToggle.remove();
                if (rightToggle) rightToggle.remove();
            }
        }

        // Initialize application
        let app;
        window.addEventListener('load', () => {
            // Initialize device detector first
            deviceDetector = new DeviceDetector();

            app = new PolygonPlayground();

            // Setup mobile menus
            setupMobileMenus();

            // Update mobile menus on resize
            window.addEventListener('deviceResize', setupMobileMenus);

            // Example: Set up telemetry callbacks
            app.setTelemetryCallbacks({
                onShapeMenuOpen: () => {
                    console.log('Shape menu opened');
                    // Track analytics event
                },
                onShapeMenuClose: () => {
                    console.log('Shape menu closed');
                    // Track analytics event
                },
                onShapeSelect: (data) => {
                    console.log('Shape selected:', data);
                    // Track shape creation: data.type, data.sides, data.polygon
                }
            });
        });

        function closeTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
        }

        // Example component usage for integration
        class CreatePolygonButton {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    onOpen: options.onOpen || (() => { }),
                    onClose: options.onClose || (() => { }),
                    onSelect: options.onSelect || (() => { }),
                    keyboard: options.keyboard || 'Ctrl+N',
                    shapes: options.shapes || [
                        { type: 'triangle', sides: 3, hint: '3 sides', icon: '‚ñ≤' },
                        { type: 'square', sides: 4, hint: '4 equal sides', icon: '‚ñ†' },
                        { type: 'rectangle', sides: 4, hint: '4 sides', icon: '‚ñ¨' },
                        { type: 'pentagon', sides: 5, hint: '5 sides', icon: '‚¨ü' },
                        { type: 'hexagon', sides: 6, hint: '6 sides', icon: '‚¨¢' },
                        { type: 'heptagon', sides: 7, hint: '7 sides (Septagon)', icon: '‚¨†' },
                        { type: 'octagon', sides: 8, hint: '8 sides', icon: '‚¨°' }
                    ]
                };
            }

            // Component methods for external integration
            open() { if (app) app.openShapeMenu(); }
            close() { if (app) app.closeShapeMenu(); }
            toggle() { if (app) app.toggleShapeMenu(); }
            createShape(type) {
                if (app) {
                    const option = document.querySelector(`[data-shape="${type}"]`);
                    if (option) app.selectShape(option);
                }
            }
        }

        // Geometry Utilities for Polygon Boolean Operations (Union & Split)
        class PolygonBoolean {
            // ... [Union Methods from previous implementation] ...

            // NEW: Split Method
            static split(polygon, lineStart, lineEnd) {
                const vertices = polygon.vertices;
                const intersections = [];
                const cutLine = { p1: lineStart, p2: lineEnd };

                for (let i = 0; i < vertices.length; i++) {
                    const current = vertices[i];
                    const next = vertices[(i + 1) % vertices.length];
                    const seg = { p1: current, p2: next };

                    const inter = this.getIntersectionInfiniteLine(seg, cutLine);
                    if (inter) {
                        intersections.push({
                            point: inter,
                            edgeIndex: i,
                            dist: this.distSq(current, inter)
                        });
                    }
                }

                if (intersections.length < 2) return null;

                // Sort intersections by edge index then distance
                intersections.sort((a, b) => {
                    if (a.edgeIndex !== b.edgeIndex) return a.edgeIndex - b.edgeIndex;
                    return a.dist - b.dist;
                });

                // Deduplicate intersections (esp. at vertices) per edge
                const uniqueInts = [];
                intersections.forEach(i => {
                    if (!uniqueInts.some(ui => ui.edgeIndex === i.edgeIndex && this.distSq(ui.point, i.point) < 0.0001)) {
                        uniqueInts.push(i);
                    }
                });

                const newSegs = [];
                let intIdx = 0;

                // 1. Build boundary segments with inserted intersection points
                for (let i = 0; i < vertices.length; i++) {
                    let lastP = vertices[i];
                    while (intIdx < uniqueInts.length && uniqueInts[intIdx].edgeIndex === i) {
                        const midP = uniqueInts[intIdx].point;
                        if (this.distSq(lastP, midP) > 0.0001) {
                            newSegs.push({ p1: { ...lastP }, p2: { ...midP } });
                        }
                        lastP = midP;
                        intIdx++;
                    }
                    if (this.distSq(lastP, vertices[(i + 1) % vertices.length]) > 0.0001) {
                        newSegs.push({ p1: { ...lastP }, p2: { ...vertices[(i + 1) % vertices.length] } });
                    }
                }

                // 2. Identify and add bridge segments (internal cut line segments)
                const bridgePoints = [];
                uniqueInts.forEach(ui => {
                    if (!bridgePoints.some(bp => this.distSq(bp, ui.point) < 0.0001)) {
                        bridgePoints.push(ui.point);
                    }
                });

                const proj = (p) => {
                    const dx = lineEnd.x - lineStart.x;
                    const dy = lineEnd.y - lineStart.y;
                    return ((p.x - lineStart.x) * dx + (p.y - lineStart.y) * dy);
                };
                bridgePoints.sort((a, b) => proj(a) - proj(b));

                for (let i = 0; i < bridgePoints.length - 1; i++) {
                    const mid = {
                        x: (bridgePoints[i].x + bridgePoints[i + 1].x) / 2,
                        y: (bridgePoints[i].y + bridgePoints[i + 1].y) / 2
                    };
                    // midpoint must be inside the original polygon
                    if (this.pointRelation(mid, vertices) === -1) {
                        newSegs.push({ p1: { ...bridgePoints[i] }, p2: { ...bridgePoints[i + 1] } });
                    }
                }

                const pieces = this.linkSegments(newSegs);
                return (pieces && pieces.length >= 2) ? pieces : null;
            }

            static isPointInside(p, vertices) {
                return this.pointRelation(p, vertices) === -1;
            }

            static getIntersectionInfiniteLine(seg, line) {
                // Line: p1, p2. Seg: p3, p4
                const x1 = line.p1.x, y1 = line.p1.y;
                const x2 = line.p2.x, y2 = line.p2.y;
                const x3 = seg.p1.x, y3 = seg.p1.y;
                const x4 = seg.p2.x, y4 = seg.p2.y;

                const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                if (Math.abs(denom) < 1e-10) return null; // Parallel

                const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

                // ub must be between 0 and 1 (segment) with a small epsilon
                const EPS = 1e-8;
                if (ub >= -EPS && ub <= 1 + EPS) {
                    return {
                        x: x1 + ua * (x2 - x1),
                        y: y1 + ua * (y2 - y1)
                    };
                }
                return null;
            }

            static isPointInside(p, vertices) {
                return this.pointRelation(p, vertices) === -1;
            }
            static union(polygons) {
                if (polygons.length < 2) return null;

                let result = this.cleanPolygon(polygons[0].vertices);

                for (let i = 1; i < polygons.length; i++) {
                    const clip = this.cleanPolygon(polygons[i].vertices);
                    const combinedCycles = this.unionTwoPolygons(result, clip);

                    if (combinedCycles && combinedCycles.length > 0) {
                        // Return all parts merged into a single path
                        result = this.mergeCycles(combinedCycles);
                    }
                }

                return result;
            }

            // New static method to merge multiple disjoint cycles into a single path
            static mergeCycles(cycles) {
                if (!cycles || cycles.length === 0) return [];
                if (cycles.length === 1) return cycles[0];

                // Start with the first cycle
                let result = [...cycles[0]];
                const remaining = cycles.slice(1);

                while (remaining.length > 0) {
                    let bestDist = Infinity;
                    let bridgeFrom = -1;
                    let bridgeToCycleIdx = -1;
                    let bridgeToVertexIdx = -1;

                    // Find the closest pair of vertices between the current result and any remaining cycle
                    for (let i = 0; i < result.length; i++) {
                        const p1 = result[i];
                        for (let c = 0; c < remaining.length; c++) {
                            const cycle = remaining[c];
                            for (let j = 0; j < cycle.length; j++) {
                                const p2 = cycle[j];
                                const d = this.distSq(p1, p2);
                                if (d < bestDist) {
                                    bestDist = d;
                                    bridgeFrom = i;
                                    bridgeToCycleIdx = c;
                                    bridgeToVertexIdx = j;
                                }
                            }
                        }
                    }

                    if (bridgeToCycleIdx !== -1) {
                        const targetCycle = remaining[bridgeToCycleIdx];

                        // Reorder target cycle to start from the bridge vertex
                        const reordered = [
                            ...targetCycle.slice(bridgeToVertexIdx),
                            ...targetCycle.slice(0, bridgeToVertexIdx)
                        ];

                        // Insert the new cycle into the result at the bridge point
                        // Path: ... -> From -> To -> ...targetCycle... -> To -> From -> ...
                        const bridgePointFrom = result[bridgeFrom];
                        const bridgePointTo = reordered[0];

                        const newPart = [
                            bridgePointFrom,
                            ...reordered,
                            bridgePointTo,
                            bridgePointFrom
                        ];

                        result.splice(bridgeFrom + 1, 0, ...newPart);
                        remaining.splice(bridgeToCycleIdx, 1);
                    } else {
                        break;
                    }
                }

                return result;
            }

            static cleanPolygon(vertices) {
                let clean = [];
                for (let i = 0; i < vertices.length; i++) {
                    const current = vertices[i];
                    const next = vertices[(i + 1) % vertices.length];
                    if (this.distSq(current, next) > 0.0001) {
                        clean.push({ x: current.x, y: current.y });
                    }
                }
                if (clean.length < 3) return clean;
                return this.ensureClockwise(clean);
            }

            static unionTwoPolygons(polyA, polyB) {
                let segsA = this.getSegments(polyA);
                let segsB = this.getSegments(polyB);
                const allSegs = this.fragmentSegments(segsA, segsB);
                const keptSegs = [];
                const EPSILON = 1e-4;

                for (let seg of allSegs) {
                    const mid = this.getMidpoint(seg);
                    const otherPoly = seg.origin === 'A' ? polyB : polyA;
                    const relation = this.pointRelation(mid, otherPoly);

                    if (relation === 1) {
                        // Strictly outside - always keep
                        keptSegs.push(seg);
                    } else if (relation === -1) {
                        // Strictly inside - always discard
                        continue;
                    } else {
                        // On boundary - check for shared/overlapping segments
                        // Find any segment from the OTHER polygon that overlaps this one
                        const otherSegs = allSegs.filter(s => s.origin !== seg.origin);
                        const matching = otherSegs.find(s =>
                            (this.distSq(s.p1, seg.p1) < EPSILON && this.distSq(s.p2, seg.p2) < EPSILON) ||
                            (this.distSq(s.p1, seg.p2) < EPSILON && this.distSq(s.p2, seg.p1) < EPSILON)
                        );

                        if (matching) {
                            // It's a shared edge.
                            const isSameDirection = this.distSq(seg.p1, matching.p1) < EPSILON;

                            if (isSameDirection) {
                                // If they are in the same direction, they both bound the union the same way.
                                // We keep one (from polygon A) to ensure the boundary exists but is not duplicated.
                                if (seg.origin === 'A') {
                                    keptSegs.push(seg);
                                }
                            } else {
                                // Opposite direction - internal shared edge. Cancel out completely.
                            }
                            continue;
                        } else {
                            // On boundary and NOT shared - must be part of the final outer boundary
                            keptSegs.push(seg);
                        }
                    }
                }
                return this.linkSegments(keptSegs);
            }

            static getSegments(vertices) {
                const segs = [];
                for (let i = 0; i < vertices.length; i++) {
                    segs.push({
                        p1: { ...vertices[i] },
                        p2: { ...vertices[(i + 1) % vertices.length] },
                        origin: null
                    });
                }
                return segs;
            }

            static fragmentSegments(segsA, segsB) {
                segsA.forEach(s => s.origin = 'A');
                segsB.forEach(s => s.origin = 'B');

                const all = [...segsA, ...segsB];
                const cuts = new Map();
                for (let i = 0; i < all.length; i++) {
                    cuts.set(i, [0, 1]);
                }

                for (let i = 0; i < all.length; i++) {
                    for (let j = i + 1; j < all.length; j++) {
                        const s1 = all[i];
                        const s2 = all[j];

                        if (Math.min(s1.p1.x, s1.p2.x) > Math.max(s2.p1.x, s2.p2.x) ||
                            Math.max(s1.p1.x, s1.p2.x) < Math.min(s2.p1.x, s2.p2.x) ||
                            Math.min(s1.p1.y, s1.p2.y) > Math.max(s2.p1.y, s2.p2.y) ||
                            Math.max(s1.p1.y, s1.p2.y) < Math.min(s2.p1.y, s2.p2.y)) continue;

                        const inter = this.getIntersection(s1.p1, s1.p2, s2.p1, s2.p2);
                        if (inter) {
                            const getT = (seg, p) => {
                                const dx = seg.p2.x - seg.p1.x;
                                const dy = seg.p2.y - seg.p1.y;
                                if (Math.abs(dx) > Math.abs(dy)) {
                                    return (p.x - seg.p1.x) / dx;
                                } else {
                                    return (p.y - seg.p1.y) / dy;
                                }
                            };

                            const t1 = getT(s1, inter);
                            const t2 = getT(s2, inter);

                            const T_EPS = 1e-5;
                            if (t1 > T_EPS && t1 < 1 - T_EPS) cuts.get(i).push(t1);
                            if (t2 > T_EPS && t2 < 1 - T_EPS) cuts.get(j).push(t2);
                        }
                    }
                }

                const result = [];
                for (let i = 0; i < all.length; i++) {
                    const seg = all[i];
                    const ts = cuts.get(i).sort((a, b) => a - b);
                    const uniqueTs = [];
                    let last = -1;
                    ts.forEach(t => {
                        if (Math.abs(t - last) > 1e-5) {
                            uniqueTs.push(t);
                            last = t;
                        }
                    });

                    for (let k = 0; k < uniqueTs.length - 1; k++) {
                        const tStart = uniqueTs[k];
                        const tEnd = uniqueTs[k + 1];

                        const pStart = {
                            x: seg.p1.x + (seg.p2.x - seg.p1.x) * tStart,
                            y: seg.p1.y + (seg.p2.y - seg.p1.y) * tStart
                        };
                        const pEnd = {
                            x: seg.p1.x + (seg.p2.x - seg.p1.x) * tEnd,
                            y: seg.p1.y + (seg.p2.y - seg.p1.y) * tEnd
                        };

                        result.push({
                            p1: pStart,
                            p2: pEnd,
                            origin: seg.origin
                        });
                    }
                }
                return result;
            }

            static linkSegments(segments) {
                if (segments.length === 0) return null;

                const verts = [];
                const EPSILON = 0.001;
                const getVertIdx = (p) => {
                    for (let i = 0; i < verts.length; i++) {
                        if (this.distSq(verts[i], p) < EPSILON) return i;
                    }
                    verts.push(p);
                    return verts.length - 1;
                };

                const adj = new Map();
                const addEdge = (u, v) => {
                    if (u === v) return;
                    if (!adj.has(u)) adj.set(u, []);
                    if (!adj.get(u).includes(v)) adj.get(u).push(v);
                };

                segments.forEach(seg => {
                    const u = getVertIdx(seg.p1);
                    const v = getVertIdx(seg.p2);
                    addEdge(u, v);
                    addEdge(v, u); // Make it bidirectional for full face traversal
                });

                if (adj.size === 0) return null;

                const cycles = [];
                const visitedDir = new Set();

                // Trace all cycles in the planar graph
                for (let u of adj.keys()) {
                    const neighbors = adj.get(u);
                    for (let v of neighbors) {
                        const key = `${u},${v}`;
                        if (visitedDir.has(key)) continue;

                        const path = [verts[u]];
                        let curr = v;
                        let prev = u;
                        visitedDir.add(key);

                        let closed = false;
                        let steps = 0;
                        while (steps < segments.length * 4) {
                            if (curr === u) {
                                closed = true;
                                break;
                            }
                            path.push(verts[curr]);

                            const nList = adj.get(curr);
                            const angleIn = Math.atan2(verts[curr].y - verts[prev].y, verts[curr].x - verts[prev].x);
                            const backRay = angleIn + Math.PI;

                            let bestNext = -1;
                            let maxTurn = -Infinity;

                            for (let next of nList) {
                                if (next === prev && nList.length > 1) continue;

                                let angleOut = Math.atan2(verts[next].y - verts[curr].y, verts[next].x - verts[curr].x);
                                let relAngle = angleOut - backRay;
                                while (relAngle < 0) relAngle += Math.PI * 2;
                                while (relAngle >= Math.PI * 2) relAngle -= Math.PI * 2;

                                // Maximize relAngle for Rightmost turn (interior faces in CW winding)
                                if (bestNext === -1 || relAngle > maxTurn) {
                                    maxTurn = relAngle;
                                    bestNext = next;
                                }
                            }

                            if (bestNext !== -1) {
                                visitedDir.add(`${curr},${bestNext}`);
                                prev = curr;
                                curr = bestNext;
                                steps++;
                            } else {
                                break;
                            }
                        }

                        if (closed && path.length >= 3) {
                            // Only keep finite faces that have a positive area (interior) in CW orientation
                            if (this.getArea(path) > 0.1) {
                                cycles.push(path);
                            }
                        }
                    }
                }

                return cycles.length > 0 ? cycles : null;
            }

            static getMidpoint(seg) {
                return {
                    x: (seg.p1.x + seg.p2.x) / 2,
                    y: (seg.p1.y + seg.p2.y) / 2
                };
            }

            static getIntersection(p1, p2, p3, p4) {
                const d = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
                if (Math.abs(d) < 1e-9) return null;

                const u = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / d;
                const v = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / d;

                if (u > 1e-6 && u < 1 - 1e-6 && v > 1e-6 && v < 1 - 1e-6) {
                    return {
                        x: p1.x + u * (p2.x - p1.x),
                        y: p1.y + u * (p2.y - p1.y)
                    };
                }
                return null;
            }

            static pointRelation(p, vertices) {
                const EPSILON = 1e-6;
                let inside = false;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const A = vertices[i];
                    const B = vertices[j];

                    // Check if point is on vertex
                    if (this.distSq(p, A) < EPSILON || this.distSq(p, B) < EPSILON) return 0;

                    // Check if point is on edge
                    if (this.isPointOnSegmentBlock(p, A, B)) return 0;

                    // Ray casting with floating point robustness
                    if (((A.y > p.y) !== (B.y > p.y)) &&
                        (p.x < (B.x - A.x) * (p.y - A.y) / (B.y - A.y) + A.x + 1e-9)) {
                        inside = !inside;
                    }
                }
                return inside ? -1 : 1;
            }

            static isPointOnSegmentBlock(p, a, b) {
                const cp = (p.y - a.y) * (b.x - a.x) - (p.x - a.x) * (b.y - a.y);
                if (Math.abs(cp) > 1e-3) return false;

                const dp = (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);
                if (dp < 0) return false;

                const lenSq = (b.x - a.x) ** 2 + (b.y - a.y) ** 2;
                if (dp > lenSq) return false;

                return true;
            }

            static ensureClockwise(vertices) {
                const area = this.getArea(vertices);
                return area > 0 ? vertices : vertices.reverse();
            }

            static getArea(vertices) {
                let area = 0;
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    area += vertices[i].x * vertices[j].y;
                    area -= vertices[j].x * vertices[i].y;
                }
                return area / 2;
            }

            static distSq(p1, p2) {
                return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
            }
        }

        // Initialize the application once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Instantiate global objects
            deviceDetector = new DeviceDetector();
            const playground = new PolygonPlayground();

            // Expose for debugging if needed
            window.polygonApp = playground;
        });
    </script>
</body>

</html>